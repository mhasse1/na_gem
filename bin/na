#!/usr/bin/env ruby
# frozen_string_literal: true

$LOAD_PATH.unshift File.join(__dir__, '..', 'lib')
require 'gli'
require 'na'

# Main application
class App
  extend GLI::App

  program_desc 'Add and list next actions for the current project'

  version Na::VERSION
  hide_commands_without_desc true
  autocomplete_commands false
  wrap_help_text :one_line unless $stdout.isatty

  config_file '.na.rc'

  desc 'File extension to consider a todo file'
  default_value 'taskpaper'
  arg_name 'EXT'
  flag :ext

  desc 'Tag to consider a next action'
  default_value 'na'
  arg_name 'TAG'
  flag %i[t na_tag]

  default_command :next

  NA::Color.coloring = $stdin.isatty

  desc 'Add a next action (deprecated, for backwards compatibility)'
  switch %i[a add]

  desc 'Set a priority 0-5 (deprecated, for backwards compatibility)'
  arg_name 'PRIORITY'
  flag %i[p priority]

  desc 'Prompt for additional notes (deprecated, for backwards compatibility)'
  switch %i[n note], negatable: false

  desc 'Recurse 3 directories deep (deprecated, for backwards compatability)'
  switch %i[r recurse], default_value: false, negatable: true

  desc 'Recurse to depth'
  arg_name 'DEPTH'
  default_value 1
  flag %i[d depth], type: :integer, must_match: /^[1-9]$/

  desc 'Display verbose output'
  switch %i[debug]

  desc 'Show next actions'
  arg_name 'OPTIONAL_QUERY'
  command %i[next show] do |c|
    c.example 'na next', desc: 'display the next actions from any todo files in the current directory'
    c.example 'na next -d 3', desc: 'display the next actions from the current directory, traversing 3 levels deep'
    c.example 'na next marked', desc: 'display next actions for a project you visited in the past'
    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], type: :integer, must_match: /^[1-9]$/

    c.desc 'Alternate tag to search for'
    c.flag %i[t tag]

    c.action do |global_options, options, args|
      if global_options[:add]
        cmd = ['add']
        cmd.push('--note') if global_options[:note]
        cmd.concat(['--priority', global_options[:priority]]) if global_options[:priority]
        cmd.push(ARGV.unshift($first_arg)) if ARGV.count > 2

        exit run(cmd)
      end

      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end

      if args.count.positive?
        tokens = []
        args.each do |arg|
          m = arg.match(/^(?<req>\+)?(?<tok>.*?)$/)
          tokens.push({
                        token: m['tok'],
                        required: !m['req'].nil?
                      })
        end
      end

      NA.na_tag = options[:tag] unless options[:tag].nil?
      require_na = true

      tag = [{ tag: tag, value: nil }]
      files, actions = NA.parse_actions(depth: depth,
                                        query: tokens,
                                        tag: tag,
                                        require_na: require_na)

      NA.output_actions(actions, depth, files: files)
    end
  end

  desc 'Add a new next action'
  long_desc 'Provides an easy way to store todos while you work. Add quick reminders and (if you set up Prompt Hooks)
  they\'ll automatically display next time you enter the directory.

  If multiple todo files are found in the current directory, a menu will allow you to pick to which
  file the action gets added.'
  arg_name 'TASK'
  command :add do |c|
    c.example 'na add "A cool feature I thought of @idea"', desc: 'Add a new action to the Inbox, including a tag'
    c.example 'na add "A bug I need to fix" -p 4 -n',
              desc: 'Add a new action to the Inbox, set its @priority to 4, and prompt for an additional note'

    c.desc 'Prompt for additional notes'
    c.switch %i[n note], negatable: false

    c.desc 'Add a priority level 1-5'
    c.arg_name 'PRIO'
    c.flag %i[p priority], must_match: /[1-5]/, type: :integer, default_value: 0

    c.desc 'Add action to specific project'
    c.arg_name 'PROJECT'
    c.default_value 'Inbox'
    c.flag %i[to]

    c.desc 'Use a tag other than the default next action tag'
    c.arg_name 'TAG'
    c.flag %i[t tag]

    c.desc 'Don\'t add next action tag to new entry'
    c.switch %i[x]

    c.desc 'Specify the file to which the task should be added'
    c.arg_name 'PATH'
    c.flag %i[f file]

    c.desc 'Search for files X directories deep'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], must_match: /^[1-9]$/, type: :integer, default_value: 1

    c.action do |_global_options, options, args|
      reader = TTY::Reader.new
      action = if args.count.positive?
                 args.join(' ').strip
               elsif TTY::Which.exist?('gum')
                 `gum input --placeholder "Enter a task" --char-limit=500 --width=#{TTY::Screen.columns}`.strip
               else
                 puts NA::Color.template('{bm}Enter task:{x}')
                 reader.read_line(NA::Color.template('{by}> {bw}')).strip
               end

      if action.nil? || action.empty?
        puts 'Empty input, cancelled'
        Process.exit 1
      end

      if options[:priority]&.to_i&.positive?
        action = "#{action.gsub(/@priority\(\d+\)/, '')} @priority(#{options[:priority]})"
      end

      na_tag = NA.na_tag
      if options[:x]
        na_tag = ''
      else
        na_tag = options[:tag] unless options[:tag].nil?
        na_tag = " @#{na_tag}"
      end

      action = "#{action.gsub(/#{na_tag}\b/, '')}#{na_tag}"

      note = if options[:note]
               if TTY::Which.exist?('gum')
                 args = ['--placeholder "Enter a note, CTRL-d to save"']
                 args << '--char-limit 0'
                 args << '--width $(tput cols)'
                 `gum write #{args.join(' ')}`.strip.split("\n")
               else
                 puts NA::Color.template('{bm}Enter a note, {bw}CTRL-d{bm} to end editing{bw}')
                 reader.read_multiline
               end
             end

      if options[:file]
        target = File.expand_path(options[:file])
        unless File.exist?(target)
          print NA::Color.template('{by}Specified file not found, create it? {w}(y/{g}N{w}){x} ')
          res = reader.read_char
          if res =~ /y/i
            basename = File.basename(target, ".#{NA.extension}")
            NA.create_todo(target, basename)
          else
            puts NA::Color.template('{r}Cancelled{x}')
            Process.exit 1
          end
        end
      else
        files = NA.find_files(depth: options[:depth])
        if files.count.zero?
          print NA::Color.template('{by}No todo file found, create one? {w}(y/{g}N{w}){x} ')
          res = reader.read_char
          if res =~ /y/i
            basename = File.expand_path('.').split('/').last
            target = "#{basename}.#{NA.extension}"
            NA.create_todo(target, basename)
            files = NA.find_files(depth: 1)
          end
        end
        target = files.count > 1 ? NA.select_file(files) : files[0]
        unless files.count.positive? && File.exist?(target)
          puts NA::Color.template('{r}Cancelled{x}')
          Process.exit 1
        end
      end

      NA.add_action(target, options[:to], action, note)
    end
  end

  desc 'Find actions matching a search pattern'
  long_desc 'Search tokens are separated by spaces. Actions matching any token in the pattern will be shown
  (partial matches allowed). Add a + before a token to make it required, e.g. `na find +feature +maybe`'
  arg_name 'PATTERN'
  command %i[find] do |c|
    c.example 'na find feature +idea +swift', desc: 'Find all actions containing feature, idea, and swift'
    c.example 'na find -x feature idea', desc: 'Find all actions containing the exact text "feature idea"'
    c.example 'na find -d 3 swift obj-c', desc: 'Find all actions 3 directories deep containing either swift or obj-c'

    c.desc 'Match pattern exactly'
    c.switch %i[x exact], negatable: false

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.action do |global_options, options, args|
      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end
      tokens = nil
      if options[:exact]
        tokens = args.join(' ')
      else
        tokens = []
        args.each do |arg|
          m = arg.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
          tokens.push({
                        token: m['tok'],
                        required: !m['req'].nil? && m['req'] == '+',
                        negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                      })
        end
      end

      files, actions = NA.parse_actions(depth: depth,
                                        search: tokens,
                                        require_na: false)
      NA.output_actions(actions, depth, files: files)
    end
  end

  desc 'Find actions matching a tag'
  long_desc 'Finds actions with tags matching the arguments. An action is shown if it
             contains any of the tags listed. Add a + before a tag to make it required.
             You can specify values using TAG=VALUE pairs.'
  arg_name 'TAG [VALUE]'
  command %i[tagged] do |c|
    c.example 'na tagged +maybe', desc: 'Show all actions tagged @maybe'
    c.example 'na tagged -d 3 feature idea', desc: 'Show all actions tagged either @feature or @idea, recurse 3 levels'
    c.example 'na tagged +priority=5', desc: 'Show actions with @priority(5)'

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.default_value 1
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.action do |global_options, options, args|
      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end

      tags = []
      args.each do |arg|
        # TODO: <> comparisons do nothing right now
        m = arg.match(/^(?<req>[+\-!])?(?<tag>[^ =<>]+)(?:(?<op>[=<>]+)(?<val>\S+))?$/)
        tags.push({
                    tag: m['tag'],
                    comp: m['op'],
                    value: m['val'],
                    required: !m['req'].nil? && m['req'] == '+',
                    negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                  })
      end

      files, actions = NA.parse_actions(depth: depth,
                                        tag: tags,
                                        require_na: false)
      NA.output_actions(actions, depth, files: files)
    end
  end

  desc 'Create a new todo file in the current directory'
  arg_name '[PROJECT]'
  command %i[init create] do |c|
    c.example 'na init', desc: 'Generate a new todo file, prompting for project name'
    c.example 'na init warpspeed', desc: 'Generate a new todo for a project called warpspeed'

    c.action do |_global_options, _options, args|
      reader = TTY::Reader.new
      if args.count.positive?
        project = args.join(' ')
      else
        project = File.expand_path('.').split('/').last
        project = reader.read_line(NA::Color.template('{y}Project name {bw}> {x}'), value: project).strip
      end

      target = "#{project}.#{NA.extension}"

      if File.exist?(target)
        print NA::Color.template("{r}File {bw}#{target}{r} already exists, overwrite it? {br}y{w}/{bg}N{x} ")
        res = reader.read_char
        Process.exit 1 unless res =~ /y/i
      end

      NA.create_todo(target, project)
    end
  end

  desc 'Open a todo file in the default editor'
  long_desc 'Let the system choose the defualt, (e.g. TaskPaper), or specify a command line utility (e.g. vim).
             If more than one todo file is found, a menu is displayed.'
  command %i[edit] do |c|
    c.example 'na edit', desc: 'Open the main todo file in the default editor'
    c.example 'na edit -d 3 -a vim', desc: 'Display a menu of all todo files three levels deep from the
               current directory, open selection in vim.'

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.default_value 1
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.desc 'Specify an editor CLI'
    c.arg_name 'EDITOR'
    c.flag %i[e editor]

    c.desc 'Specify a Mac app'
    c.arg_name 'EDITOR'
    c.flag %i[a app]

    c.action do |global_options, options, _args|
      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end
      files = NA.find_files(depth: depth)
      file = if files.count > 1
               NA.select_file(files)
             else
               files[0]
             end

      if options[:editor]
        system options[:editor], file
      else
        NA.edit_file(file: file, app: options[:app])
      end
    end
  end

  desc 'Show or install prompt hooks for the current shell'
  long_desc 'Installing the prompt hook allows you to automatically
  list next actions when you cd into a directory'
  command %i[prompt] do |c|
    c.desc 'Output the prompt hook for the current shell to STDOUT. Pass an argument to
            specify a shell (zsh, bash, fish)'
    c.arg_name '[SHELL]'
    c.command %i[show] do |s|
      s.action do |_global_options, _options, args|
        shell = if args.count.positive?
                  args[0]
                else
                  File.basename(ENV['SHELL'])
                end

        case shell
        when /^f/i
          NA::Prompt.show_prompt_hook(:fish)
        when /^z/i
          NA::Prompt.show_prompt_hook(:zsh)
        when /^b/i
          NA::Prompt.show_prompt_hook(:bash)
        end
      end
    end

    c.desc 'Install the hook for the current shell to the appropriate startup file.'
    c.arg_name '[SHELL]'
    c.command %i[install] do |s|
      s.action do |_global_options, _options, args|
        shell = if args.count.positive?
                  args[0]
                else
                  File.basename(ENV['SHELL'])
                end

        case shell
        when /^f/i
          NA::Prompt.install_prompt_hook(:fish)
        when /^z/i
          NA::Prompt.install_prompt_hook(:zsh)
        when /^b/i
          NA::Prompt.install_prompt_hook(:bash)
        end
      end
    end
  end

  pre do |global, _command, _options, _args|
    NA.verbose = global[:debug]
    NA.extension = global[:ext]
    NA.na_tag = global[:na_tag]
    NA.weed_cache_file
    true
  end

  post do |global, command, options, args|
    # Post logic here
    # Use skips_post before a command to skip this
    # block on that command only
  end

  on_error do |exception|
    case exception
    when GLI::UnknownCommand
      cmd = ['add']
      cmd.concat(ARGV.unshift($first_arg)) if ARGV.count.positive?

      exit run(cmd)
    when SystemExit
      false
    else
      true
    end
  end
end

@command = ARGV[0]
$first_arg = ARGV[1]

exit App.run(ARGV)
