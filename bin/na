#!/usr/bin/env ruby
# frozen_string_literal: true

$LOAD_PATH.unshift File.join(__dir__, '..', 'lib')
require 'gli'
require 'na'
require 'fcntl'

# Main application
class App
  extend GLI::App

  program_desc 'Add and list next actions for the current project'

  version Na::VERSION
  hide_commands_without_desc true
  autocomplete_commands false
  wrap_help_text :one_line unless $stdout.isatty

  config_file '.na.rc'

  desc 'File extension to consider a todo file'
  default_value 'taskpaper'
  arg_name 'EXT'
  flag :ext

  desc 'Tag to consider a next action'
  default_value 'na'
  arg_name 'TAG'
  flag %i[t na_tag]

  default_command :next

  NA::Color.coloring = $stdin.isatty

  desc 'Add a next action (deprecated, for backwards compatibility)'
  switch %i[a add], negatable: false

  desc 'Colorize output'
  switch %i[color], negatable: true, default_value: true

  desc 'Set a priority 0-5 (deprecated, for backwards compatibility)'
  arg_name 'PRIORITY'
  flag %i[p priority]

  desc 'Use a single file as global todo, use initconfig to make permanent'
  arg_name 'PATH'
  flag %i[f file]

  desc 'Provide a template for new/blank todo files, use initconfig to make permanent'
  arg_name 'PATH'
  flag %[template]

  desc 'Use current working directory as [p]roject, [t]ag, or [n]one'
  arg_name 'TYPE'
  flag %i[cwd_as], must_match: /^[ptn].*?$/i, default_value: 'none'

  desc 'Add all new/moved entries at [s]tart or [e]nd of target project'
  arg_name 'POSITION'
  flag %i[add_at], default_value: 'start'

  desc 'Prompt for additional notes (deprecated, for backwards compatibility)'
  switch %i[n note], negatable: false

  desc 'Recurse 3 directories deep (deprecated, for backwards compatability)'
  switch %i[r recurse], default_value: false, negatable: true

  desc 'Recurse to depth'
  arg_name 'DEPTH'
  default_value 1
  flag %i[d depth], type: :integer, must_match: /^[1-9]$/

  desc 'Display verbose output'
  switch %i[debug], default_value: false

  desc 'Show next actions'
  long_desc 'Next actions are actions which contain the next action tag (default @na),
  do not contain @done, and are not in the Archive project.
  # end

  Arguments will target a todo file from history, whether it\'s in the current
  directory or not. Todo file queries can include path components separated by /
  or :, and may use wildcards (`*` to match any text, `?` to match a single character). Multiple queries allowed (separate arguments or separated by comma).'
  arg_name 'QUERY', optional: true
  command %i[next show] do |c|
    c.example 'na next', desc: 'display the next actions from any todo files in the current directory'
    c.example 'na next -d 3', desc: 'display the next actions from the current directory, traversing 3 levels deep'
    c.example 'na next marked', desc: 'display next actions for a project you visited in the past'

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], type: :integer, must_match: /^[1-9]$/

    c.desc 'Display matches from a known todo file'
    c.arg_name 'TODO_FILE'
    c.flag %i[in todo], multiple: true

    c.desc 'Alternate tag to search for'
    c.arg_name 'TAG'
    c.flag %i[t tag]

    c.desc 'Show actions from a specific project'
    c.arg_name 'PROJECT[/SUBPROJECT]'
    c.flag %i[proj project]

    c.desc 'Match actions containing tag. Allows value comparisons'
    c.arg_name 'TAG'
    c.flag %i[tagged], multiple: true

    c.desc 'Filter results using search terms'
    c.arg_name 'QUERY'
    c.flag %i[search], multiple: true

    c.desc 'Search query is regular expression'
    c.switch %i[regex], negatable: false

    c.desc 'Search query is exact text match (not tokens)'
    c.switch %i[exact], negatable: false

    c.desc 'Include notes in output'
    c.switch %i[notes], negatable: true, default_value: false

    c.desc 'Include @done actions'
    c.switch %i[done]

    c.desc 'Output actions nested by file'
    c.switch %[nest], negatable: false

    c.desc 'Output actions nested by file and project'
    c.switch %[omnifocus], negatable: false

    c.action do |global_options, options, args|
      if global_options[:add]
        cmd = ['add']
        cmd.push('--note') if global_options[:note]
        cmd.concat(['--priority', global_options[:priority]]) if global_options[:priority]
        cmd.push(NA.command_line) if NA.command_line.count > 1
        cmd.unshift(*NA.globals)
        exit run(cmd)
      end

      options[:nest] = true if options[:omnifocus]

      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end

      all_req = options[:tagged].join(' ') !~ /[+!\-]/ && !options[:or]
      tags = []
      options[:tagged].join(',').split(/ *, */).each do |arg|
        m = arg.match(/^(?<req>[+\-!])?(?<tag>[^ =<>$\^]+?)(?:(?<op>[=<>]{1,2}|[*$\^]=)(?<val>.*?))?$/)

        tags.push({
                    tag: m['tag'].wildcard_to_rx,
                    comp: m['op'],
                    value: m['val'],
                    required: all_req || (!m['req'].nil? && m['req'] == '+'),
                    negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                  })
      end

      args.concat(options[:in])
      if args.count.positive?
        all_req = args.join(' ') !~ /[+!\-]/

        tokens = []
        args.each do |arg|
          arg.split(/ *, */).each do |a|
            m = a.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
            tokens.push({
                          token: m['tok'],
                          required: !m['req'].nil? && m['req'] == '+',
                          negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                        })
          end
        end
      end

      search = nil
      if options[:search]
        if options[:exact]
          search = options[:search].join(' ')
        elsif options[:regex]
          search = Regexp.new(options[:search].join(' '), Regexp::IGNORECASE)
        else
          search = []
          all_req = options[:search].join(' ') !~ /[+!\-]/ && !options[:or]

          options[:search].join(' ').split(/ /).each do |arg|
            m = arg.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
            search.push({
                          token: m['tok'],
                          required: all_req || (!m['req'].nil? && m['req'] == '+'),
                          negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                        })
          end
        end
      end

      NA.na_tag = options[:tag] unless options[:tag].nil?
      require_na = true

      tag = [{ tag: NA.na_tag, value: nil }, { tag: 'done', value: nil, negate: true }]
      tag.concat(tags)
      files, actions, = NA.parse_actions(depth: depth,
                                         done: options[:done],
                                         query: tokens,
                                         tag: tag,
                                         search: search,
                                         project: options[:project],
                                         require_na: require_na)

      NA.output_actions(actions, depth, files: files, notes: options[:notes], nest: options[:nest], nest_projects: options[:omnifocus])
    end
  end

  desc 'Add a new next action'
  long_desc 'Provides an easy way to store todos while you work. Add quick
  reminders and (if you set up Prompt Hooks) they\'ll automatically display
  next time you enter the directory.

  If multiple todo files are found in the current directory, a menu will
  allow you to pick to which file the action gets added.'
  arg_name 'ACTION'
  command :add do |c|
    c.example 'na add "A cool feature I thought of @idea"', desc: 'Add a new action to the Inbox, including a tag'
    c.example 'na add "A bug I need to fix" -p 4 -n',
              desc: 'Add a new action to the Inbox, set its @priority to 4, and prompt for an additional note.'
    c.example 'na add "An action item (with a note)"',
              desc: 'A parenthetical at the end of an action is interpreted as a note'

    c.desc 'Prompt for additional notes. STDIN input (piped) will be treated as a note if present.'
    c.switch %i[n note], negatable: false

    c.desc 'Add a priority level 1-5'
    c.arg_name 'PRIO'
    c.flag %i[p priority], must_match: /[1-5]/, type: :integer, default_value: 0

    c.desc 'Add action to specific project'
    c.arg_name 'PROJECT'
    c.default_value 'Inbox'
    c.flag %i[to project proj]

    c.desc 'Add task at [s]tart or [e]nd of target project'
    c.arg_name 'POSITION'
    c.flag %i[at], must_match: /^[sbea].*?$/i

    c.desc 'Add to a known todo file, partial matches allowed'
    c.arg_name 'TODO_FILE'
    c.flag %i[in todo]

    c.desc 'Use a tag other than the default next action tag'
    c.arg_name 'TAG'
    c.flag %i[t tag]

    c.desc 'Don\'t add next action tag to new entry'
    c.switch %i[x], negatable: false

    c.desc 'Specify the file to which the task should be added'
    c.arg_name 'PATH'
    c.flag %i[f file]

    c.desc 'Mark task as @done with date'
    c.switch %i[finish done], negatable: false

    c.desc 'Search for files X directories deep'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], must_match: /^[1-9]$/, type: :integer, default_value: 1

    c.action do |global_options, options, args|
      reader = TTY::Reader.new
      append = options[:at] ? options[:at] =~ /^[ae]/i : global_options[:add_at] =~ /^[ae]/

      if NA.global_file
        target = File.expand_path(NA.global_file)
        unless File.exist?(target)
          res = NA.yn(NA::Color.template('{by}Specified file not found, create it'), default: true)
          if res
            basename = File.basename(target, ".#{NA.extension}")
            NA.create_todo(target, basename, template: global_options[:template])
          else
            puts NA::Color.template('{r}Cancelled{x}')
            Process.exit 1
          end
        end
      elsif options[:file]
        target = File.expand_path(options[:file])
        unless File.exist?(target)
          res = NA.yn(NA::Color.template('{by}Specified file not found, create it'), default: true)
          if res
            basename = File.basename(target, ".#{NA.extension}")
            NA.create_todo(target, basename, template: global_options[:template])
          else
            puts NA::Color.template('{r}Cancelled{x}')
            Process.exit 1
          end
        end
      elsif options[:todo]
        todo = []
        all_req = options[:todo] !~ /[+!\-]/
        options[:todo].split(/ *, */).each do |a|
          m = a.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
          todo.push({
                      token: m['tok'],
                      required: all_req || (!m['req'].nil? && m['req'] == '+'),
                      negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                    })
        end
        dirs = NA.match_working_dir(todo)
        if dirs.count.positive?
          target = dirs[0]
        else
          todo = "#{options[:todo].sub(/#{NA.extension}$/, '')}.#{NA.extension}"
          target = File.expand_path(todo)
          unless File.exist?(target)

            res = NA.yn(NA::Color.template("{by}Specified file not found, create #{todo}"), default: true)
            NA.notify('{r}Cancelled{x}', exit_code: 1) unless res

            basename = File.basename(target, ".#{NA.extension}")
            NA.create_todo(target, basename, template: global_options[:template])
          end

        end
      else
        files = NA.find_files(depth: options[:depth])
        if files.count.zero?
          res = NA.yn(NA::Color.template('{by}No todo file found, create one'), default: true)
          if res
            basename = File.expand_path('.').split('/').last
            target = "#{basename}.#{NA.extension}"
            NA.create_todo(target, basename, template: global_options[:template])
            files = NA.find_files(depth: 1)
          end
        end
        target = files.count > 1 ? NA.select_file(files) : files[0]
        NA.notify('{r}Cancelled{x}', exit_code: 1) unless files.count.positive? && File.exist?(target)

      end

      action = if args.count.positive?
                 args.join(' ').strip
               elsif $stdin.isatty && TTY::Which.exist?('gum')
                 `gum input --placeholder "Enter a task" --char-limit=500 --width=#{TTY::Screen.columns}`.strip
               elsif $stdin.isatty
                 puts NA::Color.template('{bm}Enter task:{x}')
                 reader.read_line(NA::Color.template('{by}> {bw}')).strip
               end

      if action.nil? || action.empty?
        puts 'Empty input, cancelled'
        Process.exit 1
      end

      if options[:priority]&.to_i&.positive?
        action = "#{action.gsub(/@priority\(\d+\)/, '')} @priority(#{options[:priority]})"
      end

      note_rx = /^(.+) \((.*?)\)$/
      split_note = if action =~ note_rx
                     n = Regexp.last_match(2)
                     action.sub!(note_rx, '\1').strip!
                     n
                   end

      na_tag = NA.na_tag
      if options[:x]
        na_tag = ''
      else
        na_tag = options[:tag] unless options[:tag].nil?
        na_tag = " @#{na_tag}"
      end

      action = "#{action.gsub(/#{na_tag}\b/, '')}#{na_tag}"

      stdin_note = NA.stdin ? NA.stdin.split("\n") : []

      line_note = if options[:note] && $stdin.isatty
                    puts stdin_note unless stdin_note.nil?
                    if TTY::Which.exist?('gum')
                      args = ['--placeholder "Enter additional note, CTRL-d to save"']
                      args << '--char-limit 0'
                      args << '--width $(tput cols)'
                      `gum write #{args.join(' ')}`.strip.split("\n")
                    else
                      puts NA::Color.template('{bm}Enter a note, {bw}CTRL-d{bm} to end editing{bw}')
                      reader.read_multiline
                    end
                  end

      note = stdin_note.empty? ? [] : stdin_note
      note.concat(split_note) unless split_note.nil?
      note.concat(line_note) unless line_note.nil?

      NA.add_action(target, options[:project], action, note, finish: options[:finish], append: append)
    end
  end

  desc 'Find and mark an action as @done'
  arg_name 'ACTION'
  command %i[complete finish] do |c|
    c.example 'na complete "An existing task"',
              desc: 'Find "An existing task" and mark @done'
    c.example 'na finish "An existing task"',
              desc: 'Alias for complete'

    c.desc 'Prompt for additional notes. Input will be appended to any existing note.
    If STDIN input (piped) is detected, it will be used as a note.'
    c.switch %i[n note], negatable: false

    c.desc 'Overwrite note instead of appending'
    c.switch %i[o overwrite], negatable: false

    c.desc 'Add a @done tag to action and move to Archive'
    c.switch %i[a archive], negatable: false

    c.desc 'Specify the file to search for the task'
    c.arg_name 'PATH'
    c.flag %i[file]

    c.desc 'Search for files X directories deep'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], must_match: /^[1-9]$/, type: :integer, default_value: 1

    c.desc 'Match actions containing tag. Allows value comparisons'
    c.arg_name 'TAG'
    c.flag %i[tagged], multiple: true

    c.desc 'Act on all matches immediately (no menu)'
    c.switch %i[all], negatable: false

    c.desc 'Interpret search pattern as regular expression'
    c.switch %i[e regex], negatable: false

    c.desc 'Match pattern exactly'
    c.switch %i[x exact], negatable: false

    c.action do |global, options, args|
      options[:finish] = true
      options[:f] = true
      options[:project] = 'Archive' if options[:archive]

  # ## Add/modify commands
      action = cmd.send(:get_action, nil)
      action.call(global, options, args)
    end
  end

  desc 'Mark an action as @done and archive'
  arg_name 'ACTION'
  command %i[archive] do |c|
    c.example 'na archive "An existing task"',
              desc: 'Find "An existing task", mark @done if needed, and move to archive'

    c.desc 'Prompt for additional notes. Input will be appended to any existing note.
    If STDIN input (piped) is detected, it will be used as a note.'
    c.switch %i[n note], negatable: false

    c.desc 'Overwrite note instead of appending'
    c.switch %i[o overwrite], negatable: false

    c.desc 'Specify the file to search for the task'
    c.arg_name 'PATH'
    c.flag %i[file]

    c.desc 'Search for files X directories deep'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], must_match: /^[1-9]$/, type: :integer, default_value: 1

    c.desc 'Archive all done tasks'
    c.switch %i[done], negatable: false

    c.desc 'Match actions containing tag. Allows value comparisons'
    c.arg_name 'TAG'
    c.flag %i[tagged], multiple: true

    c.desc 'Act on all matches immediately (no menu)'
    c.switch %i[all], negatable: false

    c.desc 'Interpret search pattern as regular expression'
    c.switch %i[e regex], negatable: false

    c.desc 'Match pattern exactly'
    c.switch %i[x exact], negatable: false

    c.action do |global, options, args|
      if options[:done]
        options[:tagged] = ['done']
        options[:all] = true
      end

      options[:done] = true
      options[:finish] = true
      options[:project] = 'Archive'
  # add_commands(%w[next add complete archive update])
  # add_commands(%w[find tagged])
  # add_commands(%w[init edit todos projects prompt changes saved])
  commands_from File.expand_path('bin/commands')

  pre do |global, _command, _options, _args|
    NA.verbose = global[:debug]
    NA::Color.coloring = global[:color]
    NA.extension = global[:ext]
    NA.na_tag = global[:na_tag]
    NA.global_file = global[:file]
    NA.cwd = File.basename(ENV['PWD'])
    NA.cwd_is = if global[:cwd_as] =~ /^n/
                  :none
                else
                  global[:cwd_as] =~ /^p/ ? :project : :tag
                end
    NA.weed_cache_file
    NA.notify("{dw}{ globals: #{NA.globals}, command_line: #{NA.command_line}, command: #{NA.command}}", debug: true)
    true
  end

  post do |global, command, options, args|
    # post actions
  end

  on_error do |exception|
    case exception
    when GLI::UnknownCommand
      if NA.command_line.count == 1
        cmd = ['saved']
        cmd.concat(ARGV.unshift(NA.command_line[0]))

        exit run(cmd)
      elsif NA.globals.include?('-a') || NA.globals.include?('--add')
        cmd = ['add']
        cmd.concat(NA.command_line)
        NA.globals.delete('-a')
        NA.globals.delete('--add')
        cmd.unshift(*NA.globals)

        exit run(cmd)
      end
      true
    when SystemExit
      false
    else
      true
    end
  end

NA.stdin = $stdin.read.strip if $stdin.stat.size.positive? || $stdin.fcntl(Fcntl::F_GETFL, 0).zero?
NA.stdin = nil unless NA.stdin && NA.stdin.length.positive?

NA.globals = []
NA.command_line = []
in_globals = true
ARGV.each do |arg|
  if arg =~ /^-/ && in_globals
    NA.globals.push(arg)
  else
    NA.command_line.push(arg)
    in_globals = false
  end
end
NA.command = NA.command_line[0]

exit run(ARGV)
