#!/usr/bin/env ruby
# frozen_string_literal: true

$LOAD_PATH.unshift File.join(__dir__, '..', 'lib')
require 'gli'
require 'na'

# Main application
class App
  extend GLI::App

  program_desc 'Add and list next actions for the current project'

  version Na::VERSION
  hide_commands_without_desc true
  autocomplete_commands false
  wrap_help_text :one_line unless $stdout.isatty

  config_file '.na.rc'

  desc 'File extension to consider a todo file'
  default_value 'taskpaper'
  arg_name 'EXT'
  flag :ext

  desc 'Tag to consider a next action'
  default_value 'na'
  arg_name 'TAG'
  flag %i[t na_tag]

  default_command :next

  NA::Color.coloring = $stdin.isatty

  desc 'Add a next action (deprecated, for backwards compatibility)'
  switch %i[a add]

  desc 'Set a priority 0-5 (deprecated, for backwards compatibility)'
  arg_name 'PRIORITY'
  flag %i[p priority]

  desc 'Prompt for additional notes (deprecated, for backwards compatibility)'
  switch %i[n note], negatable: false

  desc 'Recurse 3 directories deep (deprecated, for backwards compatability)'
  switch %i[r recurse], default_value: false, negatable: true

  desc 'Recurse to depth'
  arg_name 'DEPTH'
  default_value 1
  flag %i[d depth], type: :integer, must_match: /^[1-9]$/

  desc 'Display verbose output'
  switch %i[debug]

  desc 'Show next actions'
  long_desc 'Next actions are actions which contain the next action tag (default @na),
  do not contain @done, and are not in the Archive project.

  Arguments will target a todo file from history, whether it\'s in the current
  directory or not. Todo file queries can include path components separated by /
  or :, and may use wildcards (`*` to match any text, `?` to match a single character). Multiple queries allowed (separate arguments or separated by comma).'
  arg_name 'QUERY', optional: true
  command %i[next show] do |c|
    c.example 'na next', desc: 'display the next actions from any todo files in the current directory'
    c.example 'na next -d 3', desc: 'display the next actions from the current directory, traversing 3 levels deep'
    c.example 'na next marked', desc: 'display next actions for a project you visited in the past'

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], type: :integer, must_match: /^[1-9]$/

    c.desc 'Alternate tag to search for'
    c.arg_name 'TAG'
    c.flag %i[t tag]

    c.desc 'Show actions from a specific project'
    c.arg_name 'PROJECT[/SUBPROJECT]'
    c.flag %i[proj project]

    c.desc 'Include @done actions'
    c.switch %i[done]

    c.action do |global_options, options, args|
      if global_options[:add]
        cmd = ['add']
        cmd.push('--note') if global_options[:note]
        cmd.concat(['--priority', global_options[:priority]]) if global_options[:priority]
        cmd.push(ARGV.unshift($first_arg)) if ARGV.count > 2

        exit run(cmd)
      end

      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end

      if args.count.positive?
        all_req = false

        tokens = []
        args.each do |arg|
          arg.split(/ *, */).each do |a|
            m = a.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
            tokens.push({
                          token: m['tok'],
                          required: all_req || (!m['req'].nil? && m['req'] == '+'),
                          negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                        })
          end
        end
      end

      NA.na_tag = options[:tag] unless options[:tag].nil?
      require_na = true

      tag = [{ tag: tag, value: nil }, { tag: 'done', value: nil, negate: true}]
      files, actions, = NA.parse_actions(depth: depth,
                                         done: options[:done],
                                         query: tokens,
                                         tag: tag,
                                         project: options[:project],
                                         require_na: require_na)

      NA.output_actions(actions, depth, files: files)
    end
  end

  desc 'Add a new next action'
  long_desc 'Provides an easy way to store todos while you work. Add quick
  reminders and (if you set up Prompt Hooks) they\'ll automatically display
  next time you enter the directory.

  If multiple todo files are found in the current directory, a menu will
  allow you to pick to which file the action gets added.'
  arg_name 'ACTION'
  command :add do |c|
    c.example 'na add "A cool feature I thought of @idea"', desc: 'Add a new action to the Inbox, including a tag'
    c.example 'na add "A bug I need to fix" -p 4 -n',
              desc: 'Add a new action to the Inbox, set its @priority to 4, and prompt for an additional note'
    c.example 'na add "An action item (with a note)"',
              desc: 'A parenthetical at the end of an action is interpreted as a note'

    c.desc 'Prompt for additional notes'
    c.switch %i[n note], negatable: false

    c.desc 'Add a priority level 1-5'
    c.arg_name 'PRIO'
    c.flag %i[p priority], must_match: /[1-5]/, type: :integer, default_value: 0

    c.desc 'Add action to specific project'
    c.arg_name 'PROJECT'
    c.default_value 'Inbox'
    c.flag %i[to project proj]

    c.desc 'Add to a known todo file, partial matches allowed'
    c.arg_name 'TODO_FILE'
    c.flag %i[in todo]

    c.desc 'Use a tag other than the default next action tag'
    c.arg_name 'TAG'
    c.flag %i[t tag]

    c.desc 'Don\'t add next action tag to new entry'
    c.switch %i[x]

    c.desc 'Specify the file to which the task should be added'
    c.arg_name 'PATH'
    c.flag %i[f file]

    c.desc 'Search for files X directories deep'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], must_match: /^[1-9]$/, type: :integer, default_value: 1

    c.action do |_global_options, options, args|
      reader = TTY::Reader.new
      action = if args.count.positive?
                 args.join(' ').strip
               elsif TTY::Which.exist?('gum')
                 `gum input --placeholder "Enter a task" --char-limit=500 --width=#{TTY::Screen.columns}`.strip
               else
                 puts NA::Color.template('{bm}Enter task:{x}')
                 reader.read_line(NA::Color.template('{by}> {bw}')).strip
               end

      if action.nil? || action.empty?
        puts 'Empty input, cancelled'
        Process.exit 1
      end

      if options[:priority]&.to_i&.positive?
        action = "#{action.gsub(/@priority\(\d+\)/, '')} @priority(#{options[:priority]})"
      end

      note_rx = /^(.+) \((.*?)\)$/
      split_note = if action =~ note_rx
                     n = Regexp.last_match(2)
                     action.sub!(note_rx, '\1').strip!
                     n
                   end

      na_tag = NA.na_tag
      if options[:x]
        na_tag = ''
      else
        na_tag = options[:tag] unless options[:tag].nil?
        na_tag = " @#{na_tag}"
      end

      action = "#{action.gsub(/#{na_tag}\b/, '')}#{na_tag}"

      line_note = if options[:note]
                    if TTY::Which.exist?('gum')
                      args = ['--placeholder "Enter a note, CTRL-d to save"']
                      args << '--char-limit 0'
                      args << '--width $(tput cols)'
                      `gum write #{args.join(' ')}`.strip.split("\n")
                    else
                      puts NA::Color.template('{bm}Enter a note, {bw}CTRL-d{bm} to end editing{bw}')
                      reader.read_multiline
                    end
                  end

      note = split_note.nil? ? [] : [split_note]
      note.concat(line_note) unless line_note.nil?
      note = nil if note.empty?

      if options[:file]
        target = File.expand_path(options[:file])
        unless File.exist?(target)
          print NA::Color.template('{by}Specified file not found, create it? {w}(y/{g}N{w}){x} ')
          res = reader.read_char
          if res =~ /y/i
            basename = File.basename(target, ".#{NA.extension}")
            NA.create_todo(target, basename)
          else
            puts NA::Color.template('{r}Cancelled{x}')
            Process.exit 1
          end
        end
      elsif options[:todo]
        todo = []
        options[:todo].split(/ *, */).each do |a|
          m = a.match(/^(?<req>\+)?(?<tok>.*?)$/)
          todo.push({
                      token: m['tok'],
                      required: !m['req'].nil?
                    })
        end
        dirs = NA.match_working_dir(todo)
        if dirs.count.positive?
          target = dirs[0]
        else
          todo = "#{options[:todo].sub(/#{NA.extension}$/, '')}.#{NA.extension}"
          target = File.expand_path(todo)
          unless File.exist?(target)

            res = NA.yn(NA::Color.template("{by}Specified file not found, create #{todo}"), default: true)
            if res
              basename = File.basename(target, ".#{NA.extension}")
              NA.create_todo(target, basename)
            else
              NA.notify('{r}Cancelled{x}', exit_code: 1)

            end
          end

        end
      else
        files = NA.find_files(depth: options[:depth])
        if files.count.zero?
          print NA::Color.template('{by}No todo file found, create one? {w}(y/{g}N{w}){x} ')
          res = reader.read_char
          if res =~ /y/i
            basename = File.expand_path('.').split('/').last
            target = "#{basename}.#{NA.extension}"
            NA.create_todo(target, basename)
            files = NA.find_files(depth: 1)
          end
        end
        target = files.count > 1 ? NA.select_file(files) : files[0]
        unless files.count.positive? && File.exist?(target)
          NA.notify('{r}Cancelled{x}', exit_code: 1)

        end
      end

      NA.add_action(target, options[:project], action, note)
    end
  end

  desc 'Update an existing action'
  long_desc 'Provides an easy way to complete, prioritize, and tag existing actions.

  If multiple todo files are found in the current directory, a menu will
  allow you to pick which file to act on.'
  arg_name 'ACTION'
  command %i[update] do |c|
    c.example 'na update --remove na "An existing task"', desc: 'Find "An existing task" action and remove the @na tag from it'
    c.example 'na update --tag waiting "A bug I need to fix" -p 4 -n',
              desc: 'Find "A bug..." action, add @waiting, add/update @priority(4), and prompt for an additional note'
    c.example 'na update --archive My cool action', desc: 'Add @done to "My cool action" and immediately move to Archive'

    c.desc 'Prompt for additional notes. Input will be appended to any existing note.'
    c.switch %i[n note], negatable: false

    c.desc 'Overwrite note instead of appending'
    c.switch %i[o overwrite], negatable: false

    c.desc 'Add/change a priority level 1-5'
    c.arg_name 'PRIO'
    c.flag %i[p priority], must_match: /[1-5]/, type: :integer, default_value: 0

    c.desc 'Move action to specific project'
    c.arg_name 'PROJECT'
    c.flag %i[to project proj]

    c.desc 'Use a known todo file, partial matches allowed'
    c.arg_name 'TODO_FILE'
    c.flag %i[in todo]

    c.desc 'Add a tag to the action, @tag(values) allowed'
    c.arg_name 'TAG'
    c.flag %i[t tag], multiple: true

    c.desc 'Remove a tag to the action'
    c.arg_name 'TAG'
    c.flag %i[r remove], multiple: true

    c.desc 'Add a @done tag to action'
    c.switch %i[f finish done], negatable: false

    c.desc 'Add a @done tag to action and move to Archive'
    c.switch %i[a archive], negatable: false

    c.desc 'Delete an action'
    c.switch %i[delete], negatable: false

    c.desc 'Specify the file to search for the task'
    c.arg_name 'PATH'
    c.flag %i[file]

    c.desc 'Search for files X directories deep'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], must_match: /^[1-9]$/, type: :integer, default_value: 1

    c.desc 'Match actions containing tag. Allows value comparisons'
    c.arg_name 'TAG'
    c.flag %i[tagged], multiple: true

    c.desc 'Act on all matches immediately (no menu)'
    c.switch %i[all], negatable: false

    c.desc 'Interpret search pattern as regular expression'
    c.switch %i[e regex], negatable: false

    c.desc 'Match pattern exactly'
    c.switch %i[x exact], negatable: false

    c.action do |_global_options, options, args|
      reader = TTY::Reader.new
      action = if args.count.positive?
                 args.join(' ').strip
               elsif TTY::Which.exist?('gum') && options[:tagged].empty?
                 options = [
                   %(--placeholder "Enter a task to search for"),
                   '--char-limit=500',
                   "--width=#{TTY::Screen.columns}"
                 ]
                 `gum input #{options.join(' ')}`.strip
               elsif options[:tagged].empty?
                 puts NA::Color.template('{bm}Enter search string:{x}')
                 reader.read_line(NA::Color.template('{by}> {bw}')).strip
               end

      if action
        tokens = nil
        if options[:exact]
          tokens = action
        elsif options[:regex]
          tokens = Regexp.new(action, Regexp::IGNORECASE)
        else
          tokens = []
          all_req = action !~ /[+!\-]/ && !options[:or]

          action.split(/ /).each do |arg|
            m = arg.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
            tokens.push({
                          token: m['tok'],
                          required: all_req || (!m['req'].nil? && m['req'] == '+'),
                          negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                        })
          end
        end
      end

      if (action.nil? || action.empty?) && options[:tagged].empty?
        puts 'Empty input, cancelled'
        Process.exit 1
      end

      all_req = options[:tagged].join(' ') !~ /[+!\-]/ && !options[:or]
      tags = []
      options[:tagged].join(',').split(/ *, */).each do |arg|
        m = arg.match(/^(?<req>[+\-!])?(?<tag>[^ =<>$\^]+?)(?:(?<op>[=<>]{1,2}|[*$\^]=)(?<val>.*?))?$/)

        tags.push({
                    tag: m['tag'].wildcard_to_rx,
                    comp: m['op'],
                    value: m['val'],
                    required: all_req || (!m['req'].nil? && m['req'] == '+'),
                    negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                  })
      end

      priority = options[:priority].to_i if options[:priority]&.to_i&.positive?
      add_tags = options[:tag].map { |t| t.sub(/^@/, '').wildcard_to_rx }
      remove_tags = options[:remove].map { |t| t.sub(/^@/, '').wildcard_to_rx }

      line_note = if options[:note]
                    if TTY::Which.exist?('gum')
                      args = ['--placeholder "Enter a note, CTRL-d to save"']
                      args << '--char-limit 0'
                      args << '--width $(tput cols)'
                      `gum write #{args.join(' ')}`.strip.split("\n")
                    else
                      puts NA::Color.template('{bm}Enter a note, {bw}CTRL-d{bm} to end editing{bw}')
                      reader.read_multiline
                    end
                  end

      note = line_note.nil? || line_note.empty? ? [] : line_note

      if options[:file]
        file = File.expand_path(options[:file])
        NA.notify('{r}File not found', exit_code: 1) unless File.exist?(file)

        targets = [file]
      elsif options[:todo]
        todo = []
        options[:todo].split(/ *, */).each do |a|
          m = a.match(/^(?<req>\+)?(?<tok>.*?)$/)
          todo.push({
                      token: m['tok'],
                      required: !m['req'].nil?
                    })
        end
        dirs = NA.match_working_dir(todo)

        if dirs.count == 1
          targets = [dirs[0]]
        elsif dirs.count.positive?
          targets = NA.select_file(dirs, multiple: true)
          NA.notify('{r}Cancelled', exit_code: 1) unless targets && targets.count.positive?
        else
          NA.notify('{r}Todo not found', exit_code: 1) unless targets && targets.count.positive?

        end
      else
        files = NA.find_files(depth: options[:depth])
        NA.notify('{r}No todo file found', exit_code: 1) if files.count.zero?

        targets = files.count > 1 ? NA.select_file(files, multiple: true) : [files[0]]
        NA.notify('{r}Cancelled{x}', exit_code: 1) unless files.count.positive?

      end

      options[:finish] = true if options[:archive]
      options[:project] = 'Archive' if options[:archive]

      NA.notify('{r}No search terms provided', exit_code: 1) if tokens.nil? && options[:tagged].empty?

      targets.each do |target|
        NA.update_action(target, tokens,
                         priority: priority,
                         add_tag: add_tags,
                         remove_tag: remove_tags,
                         finish: options[:finish],
                         project: options[:project],
                         delete: options[:delete],
                         note: note,
                         overwrite: options[:overwrite],
                         tagged: tags,
                         all: options[:all])
      end
    end
  end

  desc 'Find actions matching a search pattern'
  long_desc 'Search tokens are separated by spaces. Actions matching all tokens in the pattern will be shown
  (partial matches allowed). Add a + before a token to make it required, e.g. `na find +feature +maybe`'
  arg_name 'PATTERN'
  command %i[find grep] do |c|
    c.example 'na find feature idea swift', desc: 'Find all actions containing feature, idea, and swift'
    c.example 'na find -x feature idea', desc: 'Find all actions containing the exact text "feature idea"'

    c.desc 'Interpret search pattern as regular expression'
    c.switch %i[e regex], negatable: false

    c.desc 'Match pattern exactly'
    c.switch %i[x exact], negatable: false

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.desc 'Show actions from a specific todo file in history. May use wildcards (* and ?)'
    c.arg_name 'TODO_PATH'
    c.flag %i[in]

    c.desc 'Combine search tokens with OR, displaying actions matching ANY of the terms'
    c.switch %i[o or], negatable: false

    c.desc 'Show actions from a specific project'
    c.arg_name 'PROJECT[/SUBPROJECT]'
    c.flag %i[proj project]

    c.desc 'Include @done actions'
    c.switch %i[done]

    c.desc 'Show actions not matching search pattern'
    c.switch %i[v invert], negatable: false

    c.desc 'Save this search for future use'
    c.arg_name 'TITLE'
    c.flag %i[save]

    c.action do |global_options, options, args|
      if options[:save]
        title = options[:save].gsub(/[^a-z0-9]/, '_').gsub(/_+/, '_')
        NA.save_search(title, "find #{NA.command_line.map { |cmd| "\"#{cmd}\"" }.join(' ')}")
      end

      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end
      tokens = nil
      if options[:exact]
        tokens = args.join(' ')
      elsif options[:regex]
        tokens = Regexp.new(args.join(' '), Regexp::IGNORECASE)
      else
        tokens = []
        all_req = args.join(' ') !~ /[+!\-]/ && !options[:or]

        args.join(' ').split(/ /).each do |arg|
          m = arg.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
          tokens.push({
                        token: m['tok'],
                        required: all_req || (!m['req'].nil? && m['req'] == '+'),
                        negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                      })
        end
      end

      todo = nil
      if options[:in]
        todo = []
        options[:in].split(/ *, */).each do |a|
          m = a.match(/^(?<req>\+)?(?<tok>.*?)$/)
          todo.push({
                      token: m['tok'],
                      required: !m['req'].nil?
                    })
        end
      end

      files, actions, = NA.parse_actions(depth: depth,
                                         done: options[:done],
                                         query: todo,
                                         search: tokens,
                                         negate: options[:invert],
                                         regex: options[:regex],
                                         project: options[:project],
                                         require_na: false)
      regexes = if tokens.is_a?(Array)
                  tokens.delete_if { |token| token[:negate] }.map { |token| token[:token] }
                else
                  [tokens]
                end

      NA.output_actions(actions, depth, files: files, regexes: regexes)
    end
  end

  desc 'Find actions matching a tag'
  long_desc 'Finds actions with tags matching the arguments. An action is shown if it
  contains all of the tags listed. Add a + before a tag to make it required
  and others optional. You can specify values using TAG=VALUE pairs.
  Use <, >, and = for numeric comparisons, and *=, ^=, and $= for text comparisons.
  Date comparisons use natural language (`na tagged "due<=today"`) and
  are detected automatically.'
  arg_name 'TAG[=VALUE]'
  command %i[tagged] do |c|
    c.example 'na tagged maybe', desc: 'Show all actions tagged @maybe'
    c.example 'na tagged -d 3 "feature, idea"', desc: 'Show all actions tagged @feature AND @idea, recurse 3 levels'
    c.example 'na tagged --or "feature, idea"', desc: 'Show all actions tagged @feature OR @idea'
    c.example 'na tagged "priority>=4"', desc: 'Show actions with @priority(4) or @priority(5)'
    c.example 'na tagged "due<in 2 days"', desc: 'Show actions with a due date coming up in the next 2 days'

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.default_value 1
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.desc 'Show actions from a specific todo file in history. May use wildcards (* and ?)'
    c.arg_name 'TODO_PATH'
    c.flag %i[in]

    c.desc 'Combine tags with OR, displaying actions matching ANY of the tags'
    c.switch %i[o or], negatable: false

    c.desc 'Show actions from a specific project'
    c.arg_name 'PROJECT[/SUBPROJECT]'
    c.flag %i[proj project]

    c.desc 'Include @done actions'
    c.switch %i[done]

    c.desc 'Show actions not matching tags'
    c.switch %i[v invert], negatable: false

    c.desc 'Save this search for future use'
    c.arg_name 'TITLE'
    c.flag %i[save]

    c.action do |global_options, options, args|
      if options[:save]
        title = options[:save].gsub(/[^a-z0-9]/, '_').gsub(/_+/, '_')
        NA.save_search(title, "tagged #{NA.command_line.map { |cmd| "\"#{cmd}\"" }.join(' ')}")
      end

      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end

      tags = []

      all_req = args.join(' ') !~ /[+!\-]/ && !options[:or]
      args.join(',').split(/ *, */).each do |arg|
        m = arg.match(/^(?<req>[+\-!])?(?<tag>[^ =<>$\^]+?)(?:(?<op>[=<>]{1,2}|[*$\^]=)(?<val>.*?))?$/)

        tags.push({
                    tag: m['tag'].wildcard_to_rx,
                    comp: m['op'],
                    value: m['val'],
                    required: all_req || (!m['req'].nil? && m['req'] == '+'),
                    negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                  })
      end

      search_for_done = false
      tags.each { |tag| search_for_done = true if tag[:tag] =~ /done/ }
      tags.push({ tag: 'done', value: nil, negate: true}) unless search_for_done

      todo = nil
      if options[:in]
        todo = []
        options[:in].split(/ *, */).each do |a|
          m = a.match(/^(?<req>\+)?(?<tok>.*?)$/)
          todo.push({
                      token: m['tok'],
                      required: !m['req'].nil?
                    })
        end
      end

      files, actions, = NA.parse_actions(depth: depth,
                                         done: options[:done],
                                         query: todo,
                                         tag: tags,
                                         negate: options[:invert],
                                         project: options[:project],
                                         require_na: false)
      regexes = tags.delete_if { |token| token[:negate] }.map { |token| token[:token] }
      NA.output_actions(actions, depth, files: files, regexes: regexes)
    end
  end

  desc 'Create a new todo file in the current directory'
  arg_name 'PROJECT', optional: true
  command %i[init create] do |c|
    c.example 'na init', desc: 'Generate a new todo file, prompting for project name'
    c.example 'na init warpspeed', desc: 'Generate a new todo for a project called warpspeed'

    c.action do |_global_options, _options, args|
      reader = TTY::Reader.new
      if args.count.positive?
        project = args.join(' ')
      else
        project = File.expand_path('.').split('/').last
        project = reader.read_line(NA::Color.template('{y}Project name {bw}> {x}'), value: project).strip
      end

      target = "#{project}.#{NA.extension}"

      if File.exist?(target)
        print NA::Color.template("{r}File {bw}#{target}{r} already exists, overwrite it? {br}y{w}/{bg}N{x} ")
        res = reader.read_char
        Process.exit 1 unless res =~ /y/i
      end

      NA.create_todo(target, project)
    end
  end

  desc 'Open a todo file in the default editor'
  long_desc 'Let the system choose the defualt, (e.g. TaskPaper), or specify a command line utility (e.g. vim).
             If more than one todo file is found, a menu is displayed.'
  command %i[edit] do |c|
    c.example 'na edit', desc: 'Open the main todo file in the default editor'
    c.example 'na edit -d 3 -a vim', desc: 'Display a menu of all todo files three levels deep from the
               current directory, open selection in vim.'

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.default_value 1
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.desc 'Specify an editor CLI'
    c.arg_name 'EDITOR'
    c.flag %i[e editor]

    c.desc 'Specify a Mac app'
    c.arg_name 'EDITOR'
    c.flag %i[a app]

    c.action do |global_options, options, args|
      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end
      files = NA.find_files(depth: depth)
      files.delete_if { |f| f !~ /.*?(#{args.join('|')}).*?.#{NA.extension}/ } if args.count.positive?

      file = if files.count > 1
               NA.select_file(files)
             else
               files[0]
             end

      if options[:editor]
        system options[:editor], file
      else
        NA.edit_file(file: file, app: options[:app])
      end
    end
  end

  desc 'Show list of known todo files'
  long_desc 'Arguments will be interpreted as a query against which the
  list of todos will be fuzzy matched. Separate directories with
  /, :, or a space, e.g. `na todos code/marked`'
  arg_name 'QUERY', optional: true
  command %i[todos] do |c|
    c.action do |_global_options, _options, args|
      if args.count.positive?
        all_req = args.join(' ') !~ /[+!\-]/

        tokens = [{ token: '*', required: all_req, negate: false }]
        args.each do |arg|
          arg.split(/ *, */).each do |a|
            m = a.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
            tokens.push({
                          token: m['tok'],
                          required: all_req || (!m['req'].nil? && m['req'] == '+'),
                          negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                        })
          end
        end
      end

      NA.list_todos(query: tokens)
    end
  end

  desc 'Show list of projects for a file'
  long_desc 'Arguments will be interpreted as a query for a known todo file,
  fuzzy matched. Separate directories with /, :, or a space, e.g. `na projects code/marked`'
  arg_name 'QUERY', optional: true
  command %i[projects] do |c|
    c.desc 'Search for files X directories deep'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], must_match: /^[1-9]$/, type: :integer, default_value: 1

    c.desc 'Output projects as paths instead of hierarchy'
    c.switch %i[p paths], negatable: false

    c.action do |_global_options, options, args|
      if args.count.positive?
        all_req = args.join(' ') !~ /[+!\-]/

        tokens = [{ token: '*', required: all_req, negate: false }]
        args.each do |arg|
          arg.split(/ *, */).each do |a|
            m = a.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
            tokens.push({
                          token: m['tok'],
                          required: all_req || (!m['req'].nil? && m['req'] == '+'),
                          negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                        })
          end
        end
      end

      NA.list_projects(query: tokens, depth: options[:depth], paths: options[:paths])
    end
  end

  desc 'Show or install prompt hooks for the current shell'
  long_desc 'Installing the prompt hook allows you to automatically
  list next actions when you cd into a directory'
  command %i[prompt] do |c|
    c.desc 'Output the prompt hook for the current shell to STDOUT. Pass an argument to
            specify a shell (zsh, bash, fish)'
    c.arg_name 'SHELL', optional: true
    c.command %i[show] do |s|
      s.action do |_global_options, _options, args|
        shell = if args.count.positive?
                  args[0]
                else
                  File.basename(ENV['SHELL'])
                end

        case shell
        when /^f/i
          NA::Prompt.show_prompt_hook(:fish)
        when /^z/i
          NA::Prompt.show_prompt_hook(:zsh)
        when /^b/i
          NA::Prompt.show_prompt_hook(:bash)
        end
      end
    end

    c.desc 'Install the hook for the current shell to the appropriate startup file.'
    c.arg_name 'SHELL', optional: true
    c.command %i[install] do |s|
      s.action do |_global_options, _options, args|
        shell = if args.count.positive?
                  args[0]
                else
                  File.basename(ENV['SHELL'])
                end

        case shell
        when /^f/i
          NA::Prompt.install_prompt_hook(:fish)
        when /^z/i
          NA::Prompt.install_prompt_hook(:zsh)
        when /^b/i
          NA::Prompt.install_prompt_hook(:bash)
        end
      end
    end
  end

  desc 'Display the changelog'
  command %i[changes changelog] do |c|
    c.action do |_, _, _|
      changelog = File.expand_path(File.join(File.dirname(__FILE__), '..', 'CHANGELOG.md'))
      pagers = [
        'mdless',
        'mdcat',
        'bat',
        ENV['PAGER'],
        'less -FXr',
        ENV['GIT_PAGER'],
        'more -r'
      ]
      pager = pagers.find { |cmd| TTY::Which.exist?(cmd.split.first) }
      system %(#{pager} "#{changelog}")
    end
  end

  desc 'Execute a saved search'
  long_desc 'Run without argument to list saved searches'
  arg_name 'SEARCH_TITLE', optional: true
  command %i[saved] do |c|
    c.example 'na saved overdue', description: 'perform the search named "overdue"'
    c.example 'na saved over', description: 'perform the search named "overdue", assuming no other searches match "over"'
    c.example 'na saved', description: 'list available searches'

    c.desc 'Open the saved search file in $EDITOR'
    c.switch %i[e edit]

    c.desc 'Delete the specified search definition'
    c.switch %i[d delete]

    c.action do |_global_options, options, args|
      if options[:edit]
        NA.edit_searches
      end

      searches = NA.load_searches
      if args.empty?
        NA.notify("{bg}Saved searches stored in {bw}#{NA.database_path(file: 'saved_searches.yml')}")
        NA.notify(searches.map { |k, v| "{y}#{k}: {w}#{v}" }.join("\n"), exit_code: 0)
      else
        if options[:delete]
          NA.delete_search(args)
        end

        keys = searches.keys.delete_if { |k| k !~ /#{args[0]}/ }
        NA.notify("{r}Search #{args[0]} not found", exit_code: 1) if keys.empty?

        key = keys[0]
        cmd = Shellwords.shellsplit(searches[key])
        exit run(cmd)
      end
    end
  end

  pre do |global, _command, _options, _args|
    NA.verbose = global[:debug]
    NA.extension = global[:ext]
    NA.na_tag = global[:na_tag]
    NA.weed_cache_file
    true
  end

  post do |global, command, options, args|
    # Post logic here
    # Use skips_post before a command to skip this
    # block on that command only
  end

  on_error do |exception|
    case exception
    when GLI::UnknownCommand
      cmd = ['saved']
      cmd.concat(ARGV.unshift($first_arg))

      exit run(cmd)
    when SystemExit
      false
    else
      true
    end
  end
end

NA.command_line = ARGV
@command = ARGV[0]
$first_arg = ARGV[1]

exit App.run(ARGV)
