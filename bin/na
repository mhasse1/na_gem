#!/usr/bin/env ruby
$LOAD_PATH.unshift File.join(__dir__, '..', 'lib')
require 'gli'
require 'na'

class App
  extend GLI::App

  program_desc 'Add and list next actions for the current project'

  version Na::VERSION
  hide_commands_without_desc true
  autocomplete_commands false
  wrap_help_text :one_line unless $stdout.isatty

  config_file '.na.rc'

  desc 'File extension to consider a todo file'
  default_value 'taskpaper'
  arg_name 'FILE_EXTENSION'
  flag :ext

  desc 'Tag to consider a next action'
  default_value 'na'
  arg_name 'TAG'
  flag :na_tag

  default_command :next

  NA::Color.coloring = $stdin.isatty

  desc 'Add a next action (deprecated, for backwards compatibility)'
  switch %i[a add]

  desc 'Set a priority 0-5 (deprecated, for backwards compatibility)'
  arg_name 'PRIORITY'
  flag %i[p priority]

  desc 'Prompt for additional notes (deprecated, for backwards compatibility)'
  switch %i[n note]

  desc 'Recurse 3 directories deep (deprecated, for backwards compatability)'
  switch %i[r recurse], default_value: false, negatable: true

  desc 'Recurse to depth'
  arg_name 'DEPTH'
  default_value 1
  flag %i[d depth], type: :integer, must_match: /^\d+$/

  desc 'Show next actions'
  command %i[next show] do |c|
    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.desc 'Alternate tag to search for'
    c.default_value 'na'
    c.flag %i[t tag]

    c.action do |global_options, options, _|
      if global_options[:add]
        cmd = ['add']
        cmd.push('--note') if global_options[:note]
        cmd.concat(['--priority', global_options[:priority]]) if global_options[:priority]
        cmd.push(ARGV.unshift(@command))
        p cmd
        exit run(cmd)
      end

      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end
      tag = options[:tag] == global_options[:na_tag] ? nil : options[:tag]
      actions = NA.parse_actions(depth: depth,
                                 extension: global_options[:ext],
                                 na_tag: global_options[:na_tag],
                                 tag: tag)
      NA.output_actions(actions, depth, global_options[:ext])
    end
  end

  desc 'Add a new next action'
  arg_name 'TASK'
  command :add do |c|
    c.desc 'Prompt for additional notes'
    c.switch %i[n note]

    c.desc 'Add a priority level 1-5'
    c.flag %i[p priority], must_match: /[1-5]/, type: :integer, default_value: 0

    c.desc 'Use a tag other than the default next action tag'
    c.arg_name 'TAG'
    c.flag %i[t tag]

    c.desc 'Specify the file to which the task should be added'
    c.arg_name 'PATH'
    c.flag %i[f file]

    c.action do |global_options, options, args|
      reader = TTY::Reader.new
      action = if args.count.positive?
                 args.join(' ').strip
               elsif TTY::Which.exist?('gum')
                 `gum input --placeholder "Enter a task"`.strip
               else
                 puts NA::Color.template('{bm}Enter task:{x}')
                 reader.read_line(NA::Color.template('{by}> {bw}')).strip
               end

      if action.nil? || action.empty?
        puts 'Empty input, cancelled'
        Process.exit 1
      end

      if options[:priority]&.to_i&.positive?
        action = "#{action.gsub(/@priority\(\d+\)/, '')} @priority(#{options[:priority]})"
      end

      na_tag = global_options[:na_tag]
      na_tag = options[:tag] unless options[:tag].nil?

      action = "#{action.gsub(/@#{na_tag}/, '')} @#{na_tag}"

      note = if options[:note]
               if TTY::Which.exist?('gum')
                 `gum write --placeholder "Enter a note, CTRL-d to save" --width $(tput cols) --char-limit 0`.strip.split("\n")
               else
                 puts NA::Color.template('{bm}Enter a note, {bw}CTRL-d{bm} to end editing{bw}')
                 reader.read_multiline
               end
             end
      if options[:file]
        target = File.expand_path(options[:file])
        unless File.exist?(target)
          print NA::Color.template('{by}Specified file not found, create it? {w}(y/{g}N{w}){x} ')
          res = reader.read_char
          if res =~ /y/i
            basename = File.basename(target, ".#{global_options[:ext]}")
            NA.create_todo(target, basename)
          else
            puts NA::Color.template('{r}Cancelled{x}')
            Process.exit 1
          end
        end
      else
        files = NA.find_files(depth: 1, extension: global_options[:ext])
        if files.count == 0
          print NA::Color.template('{by}No todo file found, create one? {w}(y/{g}N{w}){x} ')
          res = reader.read_char
          if res =~ /y/i
            basename = File.expand_path('.').split('/').last
            target = "#{basename}.#{global_options[:ext]}"
            NA.create_todo(target, basename)
            files = NA.find_files(depth: 1, extension: global_options[:ext])
          end
        end
        target = files.count > 1 ? NA.select_file(files) : files[0]
        unless files.count.positive? && File.exist?(target)
          puts NA::Color.template('{r}Cancelled{x}')
          Process.exit 1
        end
      end

      NA.add_action(target, action, note)
    end
  end

  desc 'Find actions matching a search pattern'
  long_desc 'Search tokens are separated by spaces. Actions matching any token in the pattern will be shown
  (partial matches allowed). Add a + before a token to make it required, e.g. `na find +feature +maybe`'
  arg_name 'PATTERN'
  command %i[find] do |c|
    c.desc 'Match pattern exactly'
    c.switch %i[x exact]

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.default_value 1
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.action do |global_options, options, args|
      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end
      tokens = nil
      if options[:exact]
        tokens = args.join(' ')
      else
        tokens = []
        args.each do |arg|
          m = arg.match(/^(?<req>\+)?(?<tok>.*?)$/)
          tokens.push({
                        token: m['tok'],
                        required: !m['req'].nil?
                      })
        end
      end

      actions = NA.parse_actions(depth: depth,
                                 extension: global_options[:ext],
                                 na_tag: global_options[:na_tag],
                                 search: tokens)
      NA.output_actions(actions, depth, global_options[:ext])
    end
  end


  desc 'Find actions matching a tag'
  long_desc 'Finds actions with tags matching the arguments. An action is shown if it
  contains any of the tags listed. Add a + before a tag to make it required,
  e.g. `na tagged feature +maybe`'
  arg_name 'TAG [VALUE]'
  command %i[tagged] do |c|
    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.default_value 1
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.action do |global_options, options, args|
      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end

      tags = []
      args.each do |arg|
        # TODO: <> comparisons do nothing right now
        m = arg.match(/^(?<req>\+)?(?<tag>[^ =<>]+)(?:(?<op>[=<>]+)(?<val>\S+))?$/)
        tags.push({
                    tag: m['tag'],
                    comp: m['op'],
                    value: m['val'],
                    required: !m['req'].nil?
                  })
      end

      actions = NA.parse_actions(depth: depth,
                                 extension: global_options[:ext],
                                 na_tag: global_options[:na_tag],
                                 tag: tags)
      NA.output_actions(actions, depth, global_options[:ext])
    end
  end

  pre do |global,command,options,args|
    # Pre logic here
    # Return true to proceed; false to abort and not call the
    # chosen command
    # Use skips_pre before a command to skip this block
    # on that command only
    true
  end

  post do |global,command,options,args|
    # Post logic here
    # Use skips_post before a command to skip this
    # block on that command only
  end

  on_error do |exception|
    case exception
    when GLI::UnknownCommand
      cmd = ['add']
      if ARGV.count.positive?
        cmd.concat(ARGV.unshift($first_arg))
      end
      p cmd
      exit run(cmd)
    when SystemExit
      false
    else
      true
    end
  end
end

@command = ARGV[0]
$first_arg = ARGV[1]

exit App.run(ARGV)
