#!/usr/bin/env ruby
# frozen_string_literal: true

$LOAD_PATH.unshift File.join(__dir__, '..', 'lib')
require 'gli'
require 'na'
require 'fcntl'

# Main application
class App
  extend GLI::App

  program_desc 'Add and list next actions for the current project'

  version Na::VERSION
  hide_commands_without_desc true
  autocomplete_commands false
  wrap_help_text :one_line unless $stdout.isatty

  config_file '.na.rc'

  desc 'File extension to consider a todo file'
  default_value 'taskpaper'
  arg_name 'EXT'
  flag :ext

  desc 'Tag to consider a next action'
  default_value 'na'
  arg_name 'TAG'
  flag %i[t na_tag]

  default_command :next

  NA::Color.coloring = $stdin.isatty

  desc 'Add a next action (deprecated, for backwards compatibility)'
  switch %i[a add], negatable: false

  desc 'Colorize output'
  switch %i[color], negatable: true, default_value: true

  desc 'Set a priority 0-5 (deprecated, for backwards compatibility)'
  arg_name 'PRIORITY'
  flag %i[p priority]

  desc 'Use a single file as global todo, use --initconfig to make permanent'
  arg_name 'PATH'
  flag %i[f file]

  desc 'Provide a template for new/blank todo files, use --initconfig to make permanent'
  arg_name 'PATH'
  flag %[template]

  desc 'Use current working directory as [p]roject, [t]ag, or [n]one'
  arg_name 'TYPE'
  flag %i[cwd_as], must_match: /^[ptn].*?$/i, default_value: 'none'

  desc 'Add all new/moved entries at [s]tart or [e]nd of target project'
  arg_name 'POSITION'
  flag %i[add_at], default_value: 'start'

  desc 'Prompt for additional notes (deprecated, for backwards compatibility)'
  switch %i[n note], negatable: false

  desc 'Recurse 3 directories deep (deprecated, for backwards compatability)'
  switch %i[r recurse], default_value: false, negatable: true

  desc 'Recurse to depth'
  arg_name 'DEPTH'
  default_value 1
  flag %i[d depth], type: :integer, must_match: /^[1-9]$/

  desc 'Display verbose output'
  switch %i[debug], default_value: false

  desc 'Show next actions'
  long_desc 'Next actions are actions which contain the next action tag (default @na),
  do not contain @done, and are not in the Archive project.

  Arguments will target a todo file from history, whether it\'s in the current
  directory or not. Todo file queries can include path components separated by /
  or :, and may use wildcards (`*` to match any text, `?` to match a single character). Multiple queries allowed (separate arguments or separated by comma).'
  arg_name 'QUERY', optional: true
  command %i[next show] do |c|
    c.example 'na next', desc: 'display the next actions from any todo files in the current directory'
    c.example 'na next -d 3', desc: 'display the next actions from the current directory, traversing 3 levels deep'
    c.example 'na next marked', desc: 'display next actions for a project you visited in the past'

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], type: :integer, must_match: /^[1-9]$/

    c.desc 'Display matches from a known todo file'
    c.arg_name 'TODO_FILE'
    c.flag %i[in todo], multiple: true

    c.desc 'Alternate tag to search for'
    c.arg_name 'TAG'
    c.flag %i[t tag]

    c.desc 'Show actions from a specific project'
    c.arg_name 'PROJECT[/SUBPROJECT]'
    c.flag %i[proj project]

    c.desc 'Match actions containing tag. Allows value comparisons'
    c.arg_name 'TAG'
    c.flag %i[tagged], multiple: true

    c.desc 'Filter results using search terms'
    c.arg_name 'QUERY'
    c.flag %i[search], multiple: true

    c.desc 'Search query is regular expression'
    c.switch %i[regex], negatable: false

    c.desc 'Search query is exact text match (not tokens)'
    c.switch %i[exact], negatable: false

    c.desc 'Include notes in output'
    c.switch %i[notes], negatable: true, default_value: false

    c.desc 'Include @done actions'
    c.switch %i[done]

    c.desc 'Output actions nested by file'
    c.switch %[nest], negatable: false

    c.desc 'Output actions nested by file and project'
    c.switch %[omnifocus], negatable: false

    c.action do |global_options, options, args|
      if global_options[:add]
        cmd = ['add']
        cmd.push('--note') if global_options[:note]
        cmd.concat(['--priority', global_options[:priority]]) if global_options[:priority]
        cmd.push(NA.command_line) if NA.command_line.count > 1
        cmd.unshift(*NA.globals)
        exit run(cmd)
      end

      options[:nest] = true if options[:omnifocus]

      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end

      all_req = options[:tagged].join(' ') !~ /[+!\-]/ && !options[:or]
      tags = []
      options[:tagged].join(',').split(/ *, */).each do |arg|
        m = arg.match(/^(?<req>[+\-!])?(?<tag>[^ =<>$\^]+?)(?:(?<op>[=<>]{1,2}|[*$\^]=)(?<val>.*?))?$/)

        tags.push({
                    tag: m['tag'].wildcard_to_rx,
                    comp: m['op'],
                    value: m['val'],
                    required: all_req || (!m['req'].nil? && m['req'] == '+'),
                    negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                  })
      end

      args.concat(options[:in])
      if args.count.positive?
        all_req = args.join(' ') !~ /[+!\-]/

        tokens = []
        args.each do |arg|
          arg.split(/ *, */).each do |a|
            m = a.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
            tokens.push({
                          token: m['tok'],
                          required: !m['req'].nil? && m['req'] == '+',
                          negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                        })
          end
        end
      end

      search = nil
      if options[:search]
        if options[:exact]
          search = options[:search].join(' ')
        elsif options[:regex]
          search = Regexp.new(options[:search].join(' '), Regexp::IGNORECASE)
        else
          search = []
          all_req = options[:search].join(' ') !~ /[+!\-]/ && !options[:or]

          options[:search].join(' ').split(/ /).each do |arg|
            m = arg.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
            search.push({
                          token: m['tok'],
                          required: all_req || (!m['req'].nil? && m['req'] == '+'),
                          negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                        })
          end
        end
      end

      NA.na_tag = options[:tag] unless options[:tag].nil?
      require_na = true

      tag = [{ tag: NA.na_tag, value: nil }, { tag: 'done', value: nil, negate: true }]
      tag.concat(tags)
      files, actions, = NA.parse_actions(depth: depth,
                                         done: options[:done],
                                         query: tokens,
                                         tag: tag,
                                         search: search,
                                         project: options[:project],
                                         require_na: require_na)

      NA.output_actions(actions, depth, files: files, notes: options[:notes], nest: options[:nest], nest_projects: options[:omnifocus])
    end
  end

  desc 'Add a new next action'
  long_desc 'Provides an easy way to store todos while you work. Add quick
  reminders and (if you set up Prompt Hooks) they\'ll automatically display
  next time you enter the directory.

  If multiple todo files are found in the current directory, a menu will
  allow you to pick to which file the action gets added.'
  arg_name 'ACTION'
  command :add do |c|
    c.example 'na add "A cool feature I thought of @idea"', desc: 'Add a new action to the Inbox, including a tag'
    c.example 'na add "A bug I need to fix" -p 4 -n',
              desc: 'Add a new action to the Inbox, set its @priority to 4, and prompt for an additional note.'
    c.example 'na add "An action item (with a note)"',
              desc: 'A parenthetical at the end of an action is interpreted as a note'

    c.desc 'Prompt for additional notes. STDIN input (piped) will be treated as a note if present.'
    c.switch %i[n note], negatable: false

    c.desc 'Add a priority level 1-5'
    c.arg_name 'PRIO'
    c.flag %i[p priority], must_match: /[1-5]/, type: :integer, default_value: 0

    c.desc 'Add action to specific project'
    c.arg_name 'PROJECT'
    c.default_value 'Inbox'
    c.flag %i[to project proj]

    c.desc 'Add task at [s]tart or [e]nd of target project'
    c.arg_name 'POSITION'
    c.flag %i[at], must_match: /^[sbea].*?$/i

    c.desc 'Add to a known todo file, partial matches allowed'
    c.arg_name 'TODO_FILE'
    c.flag %i[in todo]

    c.desc 'Use a tag other than the default next action tag'
    c.arg_name 'TAG'
    c.flag %i[t tag]

    c.desc 'Don\'t add next action tag to new entry'
    c.switch %i[x], negatable: false

    c.desc 'Specify the file to which the task should be added'
    c.arg_name 'PATH'
    c.flag %i[f file]

    c.desc 'Mark task as @done with date'
    c.switch %i[finish done], negatable: false

    c.desc 'Search for files X directories deep'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], must_match: /^[1-9]$/, type: :integer, default_value: 1

    c.action do |global_options, options, args|
      reader = TTY::Reader.new
      append = options[:at] ? options[:at] =~ /^[ae]/i : global_options[:add_at] =~ /^[ae]/

      if NA.global_file
        target = File.expand_path(NA.global_file)
        unless File.exist?(target)
          res = NA.yn(NA::Color.template('{by}Specified file not found, create it'), default: true)
          if res
            basename = File.basename(target, ".#{NA.extension}")
            NA.create_todo(target, basename)
          else
            puts NA::Color.template('{r}Cancelled{x}')
            Process.exit 1
          end
        end
      elsif options[:file]
        target = File.expand_path(options[:file])
        unless File.exist?(target)
          res = NA.yn(NA::Color.template('{by}Specified file not found, create it'), default: true)
          if res
            basename = File.basename(target, ".#{NA.extension}")
            NA.create_todo(target, basename)
          else
            puts NA::Color.template('{r}Cancelled{x}')
            Process.exit 1
          end
        end
      elsif options[:todo]
        todo = []
        all_req = options[:todo] !~ /[+!\-]/
        options[:todo].split(/ *, */).each do |a|
          m = a.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
          todo.push({
                      token: m['tok'],
                      required: all_req || (!m['req'].nil? && m['req'] == '+'),
                      negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                    })
        end
        dirs = NA.match_working_dir(todo)
        if dirs.count.positive?
          target = dirs[0]
        else
          todo = "#{options[:todo].sub(/#{NA.extension}$/, '')}.#{NA.extension}"
          target = File.expand_path(todo)
          unless File.exist?(target)

            res = NA.yn(NA::Color.template("{by}Specified file not found, create #{todo}"), default: true)
            NA.notify('{r}Cancelled{x}', exit_code: 1) unless res

            basename = File.basename(target, ".#{NA.extension}")
            NA.create_todo(target, basename)
          end

        end
      else
        files = NA.find_files(depth: options[:depth])
        if files.count.zero?
          res = NA.yn(NA::Color.template('{by}No todo file found, create one'), default: true)
          if res
            basename = File.expand_path('.').split('/').last
            target = "#{basename}.#{NA.extension}"
            NA.create_todo(target, basename)
            files = NA.find_files(depth: 1)
          end
        end
        target = files.count > 1 ? NA.select_file(files) : files[0]
        NA.notify('{r}Cancelled{x}', exit_code: 1) unless files.count.positive? && File.exist?(target)

      end

      action = if args.count.positive?
                 args.join(' ').strip
               elsif $stdin.isatty && TTY::Which.exist?('gum')
                 `gum input --placeholder "Enter a task" --char-limit=500 --width=#{TTY::Screen.columns}`.strip
               elsif $stdin.isatty
                 puts NA::Color.template('{bm}Enter task:{x}')
                 reader.read_line(NA::Color.template('{by}> {bw}')).strip
               end

      if action.nil? || action.empty?
        puts 'Empty input, cancelled'
        Process.exit 1
      end

      if options[:priority]&.to_i&.positive?
        action = "#{action.gsub(/@priority\(\d+\)/, '')} @priority(#{options[:priority]})"
      end

      note_rx = /^(.+) \((.*?)\)$/
      split_note = if action =~ note_rx
                     n = Regexp.last_match(2)
                     action.sub!(note_rx, '\1').strip!
                     n
                   end

      na_tag = NA.na_tag
      if options[:x]
        na_tag = ''
      else
        na_tag = options[:tag] unless options[:tag].nil?
        na_tag = " @#{na_tag}"
      end

      action = "#{action.gsub(/#{na_tag}\b/, '')}#{na_tag}"

      stdin_note = NA.stdin ? NA.stdin.split("\n") : []

      line_note = if options[:note] && $stdin.isatty
                    puts stdin_note unless stdin_note.nil?
                    if TTY::Which.exist?('gum')
                      args = ['--placeholder "Enter additional note, CTRL-d to save"']
                      args << '--char-limit 0'
                      args << '--width $(tput cols)'
                      `gum write #{args.join(' ')}`.strip.split("\n")
                    else
                      puts NA::Color.template('{bm}Enter a note, {bw}CTRL-d{bm} to end editing{bw}')
                      reader.read_multiline
                    end
                  end

      note = stdin_note.empty? ? [] : stdin_note
      note.concat(split_note) unless split_note.nil?
      note.concat(line_note) unless line_note.nil?

      NA.add_action(target, options[:project], action, note, finish: options[:finish], append: append)
    end
  end

  desc 'Update an existing action'
  long_desc 'Provides an easy way to complete, prioritize, and tag existing actions.

  If multiple todo files are found in the current directory, a menu will
  allow you to pick which file to act on.'
  arg_name 'ACTION'
  command %i[update] do |c|
    c.example 'na update --remove na "An existing task"',
              desc: 'Find "An existing task" action and remove the @na tag from it'
    c.example 'na update --tag waiting "A bug I need to fix" -p 4 -n',
              desc: 'Find "A bug..." action, add @waiting, add/update @priority(4), and prompt for an additional note'
    c.example 'na update --archive My cool action',
              desc: 'Add @done to "My cool action" and immediately move to Archive'

    c.desc 'Prompt for additional notes. Input will be appended to any existing note.
    If STDIN input (piped) is detected, it will be used as a note.'
    c.switch %i[n note], negatable: false

    c.desc 'Overwrite note instead of appending'
    c.switch %i[o overwrite], negatable: false

    c.desc 'Add/change a priority level 1-5'
    c.arg_name 'PRIO'
    c.flag %i[p priority], must_match: /[1-5]/, type: :integer, default_value: 0

    c.desc 'When moving task, add at [s]tart or [e]nd of target project'
    c.arg_name 'POSITION'
    c.flag %i[at], must_match: /^[sbea].*?$/i

    c.desc 'Move action to specific project'
    c.arg_name 'PROJECT'
    c.flag %i[to project proj]

    c.desc 'Use a known todo file, partial matches allowed'
    c.arg_name 'TODO_FILE'
    c.flag %i[in todo]

    c.desc 'Include @done actions'
    c.switch %i[done]

    c.desc 'Add a tag to the action, @tag(values) allowed'
    c.arg_name 'TAG'
    c.flag %i[t tag], multiple: true

    c.desc 'Remove a tag to the action'
    c.arg_name 'TAG'
    c.flag %i[r remove], multiple: true

    c.desc 'Add a @done tag to action'
    c.switch %i[f finish], negatable: false

    c.desc 'Add a @done tag to action and move to Archive'
    c.switch %i[a archive], negatable: false

    c.desc 'Delete an action'
    c.switch %i[delete], negatable: false

    c.desc 'Specify the file to search for the task'
    c.arg_name 'PATH'
    c.flag %i[file]

    c.desc 'Search for files X directories deep'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], must_match: /^[1-9]$/, type: :integer, default_value: 1

    c.desc 'Match actions containing tag. Allows value comparisons'
    c.arg_name 'TAG'
    c.flag %i[tagged], multiple: true

    c.desc 'Act on all matches immediately (no menu)'
    c.switch %i[all], negatable: false

    c.desc 'Interpret search pattern as regular expression'
    c.switch %i[e regex], negatable: false

    c.desc 'Match pattern exactly'
    c.switch %i[x exact], negatable: false

    c.action do |global_options, options, args|
      reader = TTY::Reader.new
      append = options[:at] ? options[:at] =~ /^[ae]/i : global_options[:add_at] =~ /^[ae]/i

      action = if args.count.positive?
                 args.join(' ').strip
               elsif $stdin.isatty && TTY::Which.exist?('gum') && options[:tagged].empty?
                 options = [
                   %(--placeholder "Enter a task to search for"),
                   '--char-limit=500',
                   "--width=#{TTY::Screen.columns}"
                 ]
                 `gum input #{options.join(' ')}`.strip
               elsif $stdin.isatty && options[:tagged].empty?
                 puts NA::Color.template('{bm}Enter search string:{x}')
                 reader.read_line(NA::Color.template('{by}> {bw}')).strip
               end

      if action
        tokens = nil
        if options[:exact]
          tokens = action
        elsif options[:regex]
          tokens = Regexp.new(action, Regexp::IGNORECASE)
        else
          tokens = []
          all_req = action !~ /[+!\-]/ && !options[:or]

          action.split(/ /).each do |arg|
            m = arg.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
            tokens.push({
                          token: m['tok'],
                          required: all_req || (!m['req'].nil? && m['req'] == '+'),
                          negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                        })
          end
        end
      end

      if (action.nil? || action.empty?) && options[:tagged].empty?
        puts 'Empty input, cancelled'
        Process.exit 1
      end

      all_req = options[:tagged].join(' ') !~ /[+!\-]/ && !options[:or]
      tags = []
      options[:tagged].join(',').split(/ *, */).each do |arg|
        m = arg.match(/^(?<req>[+\-!])?(?<tag>[^ =<>$\^]+?)(?:(?<op>[=<>]{1,2}|[*$\^]=)(?<val>.*?))?$/)

        tags.push({
                    tag: m['tag'].wildcard_to_rx,
                    comp: m['op'],
                    value: m['val'],
                    required: all_req || (!m['req'].nil? && m['req'] == '+'),
                    negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                  })
      end

      priority = options[:priority].to_i if options[:priority]&.to_i&.positive?
      add_tags = options[:tag].map { |t| t.sub(/^@/, '').wildcard_to_rx }
      remove_tags = options[:remove].map { |t| t.sub(/^@/, '').wildcard_to_rx }

      stdin_note = NA.stdin ? NA.stdin.split("\n") : []

      line_note = if options[:note] && $stdin.isatty
                    puts stdin_note unless stdin_note.nil?
                    if TTY::Which.exist?('gum')
                      args = ['--placeholder "Enter a note, CTRL-d to save"']
                      args << '--char-limit 0'
                      args << '--width $(tput cols)'
                      `gum write #{args.join(' ')}`.strip.split("\n")
                    else
                      puts NA::Color.template('{bm}Enter a note, {bw}CTRL-d{bm} to end editing{bw}')
                      reader.read_multiline
                    end
                  end

      note = stdin_note.empty? ? [] : stdin_note
      note.concat(line_note) unless line_note.nil? || line_note.empty?

      target_proj = if options[:project]
                      options[:project]
                    elsif NA.cwd_is == :project
                      NA.cwd
                    else
                      nil
                    end

      if options[:file]
        file = File.expand_path(options[:file])
        NA.notify('{r}File not found', exit_code: 1) unless File.exist?(file)

        targets = [file]
      elsif options[:todo]
        todo = []
        options[:todo].split(/ *, */).each do |a|
          m = a.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
          todo.push({
                      token: m['tok'],
                      required: all_req || (!m['req'].nil? && m['req'] == '+'),
                      negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                    })
        end
        dirs = NA.match_working_dir(todo)

        if dirs.count == 1
          targets = [dirs[0]]
        elsif dirs.count.positive?
          targets = NA.select_file(dirs, multiple: true)
          NA.notify('{r}Cancelled', exit_code: 1) unless targets && targets.count.positive?
        else
          NA.notify('{r}Todo not found', exit_code: 1) unless targets && targets.count.positive?

        end
      else
        files = NA.find_files(depth: options[:depth])
        NA.notify('{r}No todo file found', exit_code: 1) if files.count.zero?

        targets = files.count > 1 ? NA.select_file(files, multiple: true) : [files[0]]
        NA.notify('{r}Cancelled{x}', exit_code: 1) unless files.count.positive?

      end

      options[:finish] = true if options[:archive]
      options[:project] = 'Archive' if options[:archive]

      NA.notify('{r}No search terms provided', exit_code: 1) if tokens.nil? && options[:tagged].empty?

      targets.each do |target|
        NA.update_action(target, tokens,
                         priority: priority,
                         add_tag: add_tags,
                         remove_tag: remove_tags,
                         finish: options[:finish],
                         project: target_proj,
                         delete: options[:delete],
                         note: note,
                         overwrite: options[:overwrite],
                         tagged: tags,
                         all: options[:all],
                         done: options[:done],
                         append: append)
      end
    end
  end

  desc 'Find actions matching a search pattern'
  long_desc 'Search tokens are separated by spaces. Actions matching all tokens in the pattern will be shown
  (partial matches allowed). Add a + before a token to make it required, e.g. `na find +feature +maybe`,
  add a - or ! to ignore matches containing that token.'
  arg_name 'PATTERN'
  command %i[find grep] do |c|
    c.example 'na find feature idea swift', desc: 'Find all actions containing feature, idea, and swift'
    c.example 'na find feature idea -swift', desc: 'Find all actions containing feature and idea but NOT swift'
    c.example 'na find -x feature idea', desc: 'Find all actions containing the exact text "feature idea"'

    c.desc 'Interpret search pattern as regular expression'
    c.switch %i[e regex], negatable: false

    c.desc 'Match pattern exactly'
    c.switch %i[x exact], negatable: false

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.desc 'Show actions from a specific todo file in history. May use wildcards (* and ?)'
    c.arg_name 'TODO_PATH'
    c.flag %i[in]

    c.desc 'Include notes in output'
    c.switch %i[notes], negatable: true, default_value: false

    c.desc 'Combine search tokens with OR, displaying actions matching ANY of the terms'
    c.switch %i[o or], negatable: false

    c.desc 'Show actions from a specific project'
    c.arg_name 'PROJECT[/SUBPROJECT]'
    c.flag %i[proj project]

    c.desc 'Match actions containing tag. Allows value comparisons'
    c.arg_name 'TAG'
    c.flag %i[tagged], multiple: true

    c.desc 'Include @done actions'
    c.switch %i[done]

    c.desc 'Show actions not matching search pattern'
    c.switch %i[v invert], negatable: false

    c.desc 'Save this search for future use'
    c.arg_name 'TITLE'
    c.flag %i[save]

    c.desc 'Output actions nested by file'
    c.switch %[nest], negatable: false

    c.desc 'Output actions nested by file and project'
    c.switch %[omnifocus], negatable: false

    c.action do |global_options, options, args|
      options[:nest] = true if options[:omnifocus]

      if options[:save]
        title = options[:save].gsub(/[^a-z0-9]/, '_').gsub(/_+/, '_')
        NA.save_search(title, "#{NA.command_line.join(' ').sub(/ --save[= ]*\S+/, '').split(' ').map { |t| %("#{t}") }.join(' ')}")
      end


      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end

      all_req = options[:tagged].join(' ') !~ /[+!\-]/ && !options[:or]
      tags = []
      options[:tagged].join(',').split(/ *, */).each do |arg|
        m = arg.match(/^(?<req>[+\-!])?(?<tag>[^ =<>$\^]+?)(?:(?<op>[=<>]{1,2}|[*$\^]=)(?<val>.*?))?$/)

        tags.push({
                    tag: m['tag'].wildcard_to_rx,
                    comp: m['op'],
                    value: m['val'],
                    required: all_req || (!m['req'].nil? && m['req'] == '+'),
                    negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                  })
      end

      tokens = nil
      if options[:exact]
        tokens = args.join(' ')
      elsif options[:regex]
        tokens = Regexp.new(args.join(' '), Regexp::IGNORECASE)
      else
        tokens = []
        all_req = args.join(' ') !~ /[+!\-]/ && !options[:or]

        args.join(' ').split(/ /).each do |arg|
          m = arg.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
          tokens.push({
                        token: m['tok'],
                        required: all_req || (!m['req'].nil? && m['req'] == '+'),
                        negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                      })
        end
      end

      todo = nil
      if options[:in]
        todo = []
        options[:in].split(/ *, */).each do |a|
          m = a.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
          todo.push({
                      token: m['tok'],
                      required: all_req || (!m['req'].nil? && m['req'] == '+'),
                      negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                    })
        end
      end

      files, actions, = NA.parse_actions(depth: depth,
                                         done: options[:done],
                                         query: todo,
                                         search: tokens,
                                         tag: tags,
                                         negate: options[:invert],
                                         regex: options[:regex],
                                         project: options[:project],
                                         require_na: false)
      regexes = if tokens.is_a?(Array)
                  tokens.delete_if { |token| token[:negate] }.map { |token| token[:token] }
                else
                  [tokens]
                end

      NA.output_actions(actions, depth, files: files, regexes: regexes, notes: options[:notes], nest: options[:nest], nest_projects: options[:omnifocus])
    end
  end

  desc 'Find actions matching a tag'
  long_desc 'Finds actions with tags matching the arguments. An action is shown if it
  contains all of the tags listed. Add a + before a tag to make it required
  and others optional. You can specify values using TAG=VALUE pairs.
  Use <, >, and = for numeric comparisons, and *=, ^=, and $= for text comparisons.
  Date comparisons use natural language (`na tagged "due<=today"`) and
  are detected automatically.'
  arg_name 'TAG[=VALUE]'
  command %i[tagged] do |c|
    c.example 'na tagged maybe', desc: 'Show all actions tagged @maybe'
    c.example 'na tagged -d 3 "feature, idea"', desc: 'Show all actions tagged @feature AND @idea, recurse 3 levels'
    c.example 'na tagged --or "feature, idea"', desc: 'Show all actions tagged @feature OR @idea'
    c.example 'na tagged "priority>=4"', desc: 'Show actions with @priority(4) or @priority(5)'
    c.example 'na tagged "due<in 2 days"', desc: 'Show actions with a due date coming up in the next 2 days'

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.default_value 1
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.desc 'Show actions from a specific todo file in history. May use wildcards (* and ?)'
    c.arg_name 'TODO_PATH'
    c.flag %i[in]

    c.desc 'Include notes in output'
    c.switch %i[notes], negatable: true, default_value: false

    c.desc 'Combine tags with OR, displaying actions matching ANY of the tags'
    c.switch %i[o or], negatable: false

    c.desc 'Show actions from a specific project'
    c.arg_name 'PROJECT[/SUBPROJECT]'
    c.flag %i[proj project]

    c.desc 'Filter results using search terms'
    c.arg_name 'QUERY'
    c.flag %i[search], multiple: true

    c.desc 'Search query is regular expression'
    c.switch %i[regex], negatable: false

    c.desc 'Search query is exact text match (not tokens)'
    c.switch %i[exact], negatable: false

    c.desc 'Include @done actions'
    c.switch %i[done]

    c.desc 'Show actions not matching tags'
    c.switch %i[v invert], negatable: false

    c.desc 'Save this search for future use'
    c.arg_name 'TITLE'
    c.flag %i[save]

    c.desc 'Output actions nested by file'
    c.switch %[nest], negatable: false

    c.desc 'Output actions nested by file and project'
    c.switch %[omnifocus], negatable: false

    c.action do |global_options, options, args|
      options[:nest] = true if options[:omnifocus]

      if options[:save]
        title = options[:save].gsub(/[^a-z0-9]/, '_').gsub(/_+/, '_')
        NA.save_search(title, "#{NA.command_line.join(' ').sub(/ --save[= ]*\S+/, '').split(' ').map { |t| %("#{t}") }.join(' ')}")
      end

      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end

      tags = []

      all_req = args.join(' ') !~ /[+!\-]/ && !options[:or]
      args.join(',').split(/ *, */).each do |arg|
        m = arg.match(/^(?<req>[+\-!])?(?<tag>[^ =<>$\^]+?)(?:(?<op>[=<>]{1,2}|[*$\^]=)(?<val>.*?))?$/)

        tags.push({
                    tag: m['tag'].wildcard_to_rx,
                    comp: m['op'],
                    value: m['val'],
                    required: all_req || (!m['req'].nil? && m['req'] == '+'),
                    negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                  })
      end

      search_for_done = false
      tags.each { |tag| search_for_done = true if tag[:tag] =~ /done/ }
      tags.push({ tag: 'done', value: nil, negate: true}) unless search_for_done

      tokens = nil
      if options[:search]
        if options[:exact]
          tokens = options[:search].join(' ')
        elsif options[:regex]
          tokens = Regexp.new(options[:search].join(' '), Regexp::IGNORECASE)
        else
          tokens = []
          all_req = options[:search].join(' ') !~ /[+!\-]/ && !options[:or]

          options[:search].join(' ').split(/ /).each do |arg|
            m = arg.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
            tokens.push({
                          token: m['tok'],
                          required: all_req || (!m['req'].nil? && m['req'] == '+'),
                          negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                        })
          end
        end
      end

      todo = nil
      if options[:in]
        todo = []
        options[:in].split(/ *, */).each do |a|
          m = a.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
          todo.push({
                      token: m['tok'],
                      required: all_req || (!m['req'].nil? && m['req'] == '+'),
                      negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                    })
        end
      end

      files, actions, = NA.parse_actions(depth: depth,
                                         done: options[:done],
                                         query: todo,
                                         search: tokens,
                                         tag: tags,
                                         negate: options[:invert],
                                         project: options[:project],
                                         require_na: false)
      # regexes = tags.delete_if { |token| token[:negate] }.map { |token| token[:token] }
      regexes = if tokens.is_a?(Array)
                  tokens.delete_if { |token| token[:negate] }.map { |token| token[:token] }
                else
                  [tokens]
                end
      NA.output_actions(actions, depth, files: files, regexes: regexes, notes: options[:notes], nest: options[:nest], nest_projects: options[:omnifocus])
    end
  end

  desc 'Create a new todo file in the current directory'
  arg_name 'PROJECT', optional: true
  command %i[init create] do |c|
    c.example 'na init', desc: 'Generate a new todo file, prompting for project name'
    c.example 'na init warpspeed', desc: 'Generate a new todo for a project called warpspeed'

    c.action do |_global_options, _options, args|
      reader = TTY::Reader.new
      if args.count.positive?
        project = args.join(' ')
      elsif
        project = File.expand_path('.').split('/').last
        project = reader.read_line(NA::Color.template('{y}Project name {bw}> {x}'), value: project).strip if $stdin.isatty
      end

      target = "#{project}.#{NA.extension}"

      if File.exist?(target)
        res = NA.yn(NA::Color.template("{r}File {bw}#{target}{r} already exists, overwrite it"), default: false)
        Process.exit 1 unless res

      end

      NA.create_todo(target, project)
    end
  end

  desc 'Open a todo file in the default editor'
  long_desc 'Let the system choose the defualt, (e.g. TaskPaper), or specify a command line utility (e.g. vim).
             If more than one todo file is found, a menu is displayed.'
  command %i[edit] do |c|
    c.example 'na edit', desc: 'Open the main todo file in the default editor'
    c.example 'na edit -d 3 -a vim', desc: 'Display a menu of all todo files three levels deep from the
               current directory, open selection in vim.'

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.default_value 1
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.desc 'Specify an editor CLI'
    c.arg_name 'EDITOR'
    c.flag %i[e editor]

    c.desc 'Specify a Mac app'
    c.arg_name 'EDITOR'
    c.flag %i[a app]

    c.action do |global_options, options, args|
      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end
      files = NA.find_files(depth: depth)
      files.delete_if { |f| f !~ /.*?(#{args.join('|')}).*?.#{NA.extension}/ } if args.count.positive?

      file = if files.count > 1
               NA.select_file(files)
             else
               files[0]
             end

      if options[:editor]
        system options[:editor], file
      else
        NA.edit_file(file: file, app: options[:app])
      end
    end
  end

  desc 'Show list of known todo files'
  long_desc 'Arguments will be interpreted as a query against which the
  list of todos will be fuzzy matched. Separate directories with
  /, :, or a space, e.g. `na todos code/marked`'
  arg_name 'QUERY', optional: true
  command %i[todos] do |c|
    c.action do |_global_options, _options, args|
      if args.count.positive?
        all_req = args.join(' ') !~ /[+!\-]/

        tokens = [{ token: '*', required: all_req, negate: false }]
        args.each do |arg|
          arg.split(/ *, */).each do |a|
            m = a.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
            tokens.push({
                          token: m['tok'],
                          required: all_req || (!m['req'].nil? && m['req'] == '+'),
                          negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                        })
          end
        end
      end

      NA.list_todos(query: tokens)
    end
  end

  desc 'Show list of projects for a file'
  long_desc 'Arguments will be interpreted as a query for a known todo file,
  fuzzy matched. Separate directories with /, :, or a space, e.g. `na projects code/marked`'
  arg_name 'QUERY', optional: true
  command %i[projects] do |c|
    c.desc 'Search for files X directories deep'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], must_match: /^[1-9]$/, type: :integer, default_value: 1

    c.desc 'Output projects as paths instead of hierarchy'
    c.switch %i[p paths], negatable: false

    c.action do |_global_options, options, args|
      if args.count.positive?
        all_req = args.join(' ') !~ /[+!\-]/

        tokens = [{ token: '*', required: all_req, negate: false }]
        args.each do |arg|
          arg.split(/ *, */).each do |a|
            m = a.match(/^(?<req>[+\-!])?(?<tok>.*?)$/)
            tokens.push({
                          token: m['tok'],
                          required: all_req || (!m['req'].nil? && m['req'] == '+'),
                          negate: !m['req'].nil? && m['req'] =~ /[!\-]/
                        })
          end
        end
      end

      NA.list_projects(query: tokens, depth: options[:depth], paths: options[:paths])
    end
  end

  desc 'Show or install prompt hooks for the current shell'
  long_desc 'Installing the prompt hook allows you to automatically
  list next actions when you cd into a directory'
  command %i[prompt] do |c|
    c.desc 'Output the prompt hook for the current shell to STDOUT. Pass an argument to
            specify a shell (zsh, bash, fish)'
    c.arg_name 'SHELL', optional: true
    c.command %i[show] do |s|
      s.action do |_global_options, _options, args|
        shell = if args.count.positive?
                  args[0]
                else
                  File.basename(ENV['SHELL'])
                end

        case shell
        when /^f/i
          NA::Prompt.show_prompt_hook(:fish)
        when /^z/i
          NA::Prompt.show_prompt_hook(:zsh)
        when /^b/i
          NA::Prompt.show_prompt_hook(:bash)
        end
      end
    end

    c.desc 'Install the hook for the current shell to the appropriate startup file.'
    c.arg_name 'SHELL', optional: true
    c.command %i[install] do |s|
      s.action do |_global_options, _options, args|
        shell = if args.count.positive?
                  args[0]
                else
                  File.basename(ENV['SHELL'])
                end

        case shell
        when /^f/i
          NA::Prompt.install_prompt_hook(:fish)
        when /^z/i
          NA::Prompt.install_prompt_hook(:zsh)
        when /^b/i
          NA::Prompt.install_prompt_hook(:bash)
        end
      end
    end
  end

  desc 'Display the changelog'
  command %i[changes changelog] do |c|
    c.action do |_, _, _|
      changelog = File.expand_path(File.join(File.dirname(__FILE__), '..', 'CHANGELOG.md'))
      pagers = [
        'mdless',
        'mdcat',
        'bat',
        ENV['PAGER'],
        'less -FXr',
        ENV['GIT_PAGER'],
        'more -r'
      ]
      pager = pagers.find { |cmd| TTY::Which.exist?(cmd.split.first) }
      system %(#{pager} "#{changelog}")
    end
  end

  desc 'Execute a saved search'
  long_desc 'Run without argument to list saved searches'
  arg_name 'SEARCH_TITLE', optional: true
  command %i[saved] do |c|
    c.example 'na tagged "+maybe,+priority<=3" --save maybelater', description: 'save a search called "maybelater"'
    c.example 'na saved maybelater', description: 'perform the search named "maybelater"'
    c.example 'na saved maybe',
              description: 'perform the search named "maybelater", assuming no other searches match "maybe"'
    c.example 'na maybe',
              description: 'na run with no command and a single argument automatically performs a matching saved search'
    c.example 'na saved', description: 'list available searches'

    c.desc 'Open the saved search file in $EDITOR'
    c.switch %i[e edit], negatable: false

    c.desc 'Delete the specified search definition'
    c.switch %i[d delete], negatable: false

    c.action do |_global_options, options, args|
      NA.edit_searches if options[:edit]

      searches = NA.load_searches
      if args.empty?
        NA.notify("{bg}Saved searches stored in {bw}#{NA.database_path(file: 'saved_searches.yml')}")
        NA.notify(searches.map { |k, v| "{y}#{k}: {w}#{v}" }.join("\n"), exit_code: 0)
      else
        NA.delete_search(args) if options[:delete]

        keys = searches.keys.delete_if { |k| k !~ /#{args[0]}/ }
        NA.notify("{r}Search #{args[0]} not found", exit_code: 1) if keys.empty?

        key = keys[0]
        cmd = Shellwords.shellsplit(searches[key])
        exit run(cmd)
      end
    end
  end

  pre do |global, _command, _options, _args|
    NA.verbose = global[:debug]
    NA::Color.coloring = global[:color]
    NA.extension = global[:ext]
    NA.na_tag = global[:na_tag]
    NA.global_file = global[:file]
    NA.cwd = File.basename(ENV['PWD'])
    NA.cwd_is = if global[:cwd_as] =~ /^n/
                  :none
                else
                  global[:cwd_as] =~ /^p/ ? :project : :tag
                end
    NA.weed_cache_file
    NA.notify("{dw}{ globals: #{NA.globals}, command_line: #{NA.command_line}, command: #{NA.command}}", debug: true)
    true
  end

  post do |global, command, options, args|
    # post actions
  end

  on_error do |exception|
    case exception
    when GLI::UnknownCommand
      if NA.command_line.count == 1
        cmd = ['saved']
        cmd.concat(ARGV.unshift(NA.command_line[0]))

        exit run(cmd)
      elsif NA.globals.include?('-a') || NA.globals.include?('--add')
        cmd = ['add']
        cmd.concat(NA.command_line)
        NA.globals.delete('-a')
        NA.globals.delete('--add')
        cmd.unshift(*NA.globals)

        exit run(cmd)
      end
      true
    when SystemExit
      false
    else
      true
    end
  end
end

NA.stdin = $stdin.read.strip if $stdin.stat.size.positive? || $stdin.fcntl(Fcntl::F_GETFL, 0).zero?
NA.stdin = nil unless NA.stdin && NA.stdin.length.positive?

NA.globals = []
NA.command_line = []
in_globals = true
ARGV.each do |arg|
  if arg =~ /^-/ && in_globals
    NA.globals.push(arg)
  else
    NA.command_line.push(arg)
    in_globals = false
  end
end
NA.command = NA.command_line[0]

exit App.run(ARGV)
