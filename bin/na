#!/usr/bin/env ruby
$LOAD_PATH.unshift File.join(__dir__, '..', 'lib')
require 'gli'
require 'na'

class App
  extend GLI::App

  program_desc 'Add and list next actions for the current project'

  version Na::VERSION
  hide_commands_without_desc true
  autocomplete_commands false
  wrap_help_text :one_line unless $stdout.isatty

  config_file '.na.rc'

  desc 'File extension to consider a todo file'
  default_value 'taskpaper'
  arg_name 'FILE_EXTENSION'
  flag :ext

  desc 'Tag to consider a next action'
  default_value 'na'
  arg_name 'TAG'
  flag :na_tag

  default_command :next

  NA::Color.coloring = $stdin.isatty

  desc 'Add a next action (deprecated, for backwards compatibility)'
  switch %i[a add]

  desc 'Set a priority 0-5 (deprecated, for backwards compatibility)'
  arg_name 'PRIORITY'
  flag %i[p priority]

  desc 'Prompt for additional notes (deprecated, for backwards compatibility)'
  switch %i[n note]

  desc 'Recurse 3 directories deep (deprecated, for backwards compatability)'
  switch %i[r recurse], default_value: false, negatable: true

  desc 'Recurse to depth'
  arg_name 'DEPTH'
  default_value 1
  flag %i[d depth], type: :integer, must_match: /^\d+$/

  desc 'Show next actions'
  arg_name 'OPTIONAL_QUERY'
  command %i[next show] do |c|
    c.example 'doing next', desc: 'display the next actions from any todo files in the current directory'
    c.example 'doing next -d 3', desc: 'display the next actions from the current directory and its children, 3 levels deep'

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.desc 'Alternate tag to search for'
    c.default_value 'na'
    c.flag %i[t tag]

    c.action do |global_options, options, args|
      if global_options[:add]
        cmd = ['add']
        cmd.push('--note') if global_options[:note]
        cmd.concat(['--priority', global_options[:priority]]) if global_options[:priority]
        cmd.push(ARGV.unshift($first_arg)) if ARGV.count > 2

        exit run(cmd)
      end


      if args.count.positive?
        tokens = []
        args.each do |arg|
          m = arg.match(/^(?<req>\+)?(?<tok>.*?)$/)
          tokens.push({
                        token: m['tok'],
                        required: !m['req'].nil?
                      })
        end
      end

      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end
      tag = options[:tag] == global_options[:na_tag] ? nil : options[:tag]
      actions = NA.parse_actions(depth: depth,
                                 query: tokens,
                                 extension: global_options[:ext],
                                 na_tag: global_options[:na_tag],
                                 tag: tag)

      NA.output_actions(actions, depth, global_options[:ext])
    end
  end

  desc 'Add a new next action'
  long_desc 'Provides an easy way to store todos while you work. Add quick reminders and (if you set up Prompt Hooks)
  they\'ll automatically display next time you enter the directory.

  If multiple todo files are found in the current directory, a menu will allow you to pick to which
  file the action gets added.'
  arg_name 'TASK'
  command :add do |c|
    c.example 'na add "A cool feature I thought of @idea"', desc: 'Add a new action to the Inbox, including a tag'
    c.example 'na add "A bug I need to fix" -p 4 -n',
              desc: 'Add a new action to the Inbox, set its @priority to 4, and prompt for an additional note'

    c.desc 'Prompt for additional notes'
    c.switch %i[n note]

    c.desc 'Add a priority level 1-5'
    c.flag %i[p priority], must_match: /[1-5]/, type: :integer, default_value: 0

    c.desc 'Use a tag other than the default next action tag'
    c.arg_name 'TAG'
    c.flag %i[t tag]

    c.desc 'Specify the file to which the task should be added'
    c.arg_name 'PATH'
    c.flag %i[f file]

    c.action do |global_options, options, args|
      reader = TTY::Reader.new
      action = if args.count.positive?
                 args.join(' ').strip
               elsif TTY::Which.exist?('gum')
                 `gum input --placeholder "Enter a task" --char-limit=500 --width=#{TTY::Screen.columns}`.strip
               else
                 puts NA::Color.template('{bm}Enter task:{x}')
                 reader.read_line(NA::Color.template('{by}> {bw}')).strip
               end

      if action.nil? || action.empty?
        puts 'Empty input, cancelled'
        Process.exit 1
      end

      if options[:priority]&.to_i&.positive?
        action = "#{action.gsub(/@priority\(\d+\)/, '')} @priority(#{options[:priority]})"
      end

      na_tag = global_options[:na_tag]
      na_tag = options[:tag] unless options[:tag].nil?

      action = "#{action.gsub(/@#{na_tag}/, '')} @#{na_tag}"

      note = if options[:note]
               if TTY::Which.exist?('gum')
                 `gum write --placeholder "Enter a note, CTRL-d to save" --width $(tput cols) --char-limit 0`.strip.split("\n")
               else
                 puts NA::Color.template('{bm}Enter a note, {bw}CTRL-d{bm} to end editing{bw}')
                 reader.read_multiline
               end
             end
      if options[:file]
        target = File.expand_path(options[:file])
        unless File.exist?(target)
          print NA::Color.template('{by}Specified file not found, create it? {w}(y/{g}N{w}){x} ')
          res = reader.read_char
          if res =~ /y/i
            basename = File.basename(target, ".#{global_options[:ext]}")
            NA.create_todo(target, basename)
          else
            puts NA::Color.template('{r}Cancelled{x}')
            Process.exit 1
          end
        end
      else
        files = NA.find_files(depth: 1, extension: global_options[:ext])
        if files.count == 0
          print NA::Color.template('{by}No todo file found, create one? {w}(y/{g}N{w}){x} ')
          res = reader.read_char
          if res =~ /y/i
            basename = File.expand_path('.').split('/').last
            target = "#{basename}.#{global_options[:ext]}"
            NA.create_todo(target, basename)
            files = NA.find_files(depth: 1, extension: global_options[:ext])
          end
        end
        target = files.count > 1 ? NA.select_file(files) : files[0]
        unless files.count.positive? && File.exist?(target)
          puts NA::Color.template('{r}Cancelled{x}')
          Process.exit 1
        end
      end

      NA.save_working_dir(File.expand_path(target))
      NA.add_action(target, action, note)
    end
  end

  desc 'Find actions matching a search pattern'
  long_desc 'Search tokens are separated by spaces. Actions matching any token in the pattern will be shown
  (partial matches allowed). Add a + before a token to make it required, e.g. `na find +feature +maybe`'
  arg_name 'PATTERN'
  command %i[find] do |c|
    c.example 'na find feature +idea +swift', desc: 'Find all actions containing feature, idea, and swift'
    c.example 'na find -x feature idea', desc: 'Find all actions containing the exact text "feature idea"'
    c.example 'na find -d 3 swift obj-c', desc: 'Find all actions 3 directories deep containing either swift or obj-c'

    c.desc 'Match pattern exactly'
    c.switch %i[x exact]

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.default_value 1
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.action do |global_options, options, args|
      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end
      tokens = nil
      if options[:exact]
        tokens = args.join(' ')
      else
        tokens = []
        args.each do |arg|
          m = arg.match(/^(?<req>\+)?(?<tok>.*?)$/)
          tokens.push({
                        token: m['tok'],
                        required: !m['req'].nil?
                      })
        end
      end

      actions = NA.parse_actions(depth: depth,
                                 extension: global_options[:ext],
                                 na_tag: global_options[:na_tag],
                                 search: tokens)
      NA.output_actions(actions, depth, global_options[:ext])
    end
  end


  desc 'Find actions matching a tag'
  long_desc 'Finds actions with tags matching the arguments. An action is shown if it
  contains any of the tags listed. Add a + before a tag to make it required,
  e.g. `na tagged feature +maybe`'
  arg_name 'TAG [VALUE]'
  command %i[tagged] do |c|
    c.example 'na tagged +maybe', desc: 'Show all actions tagged @maybe'
    c.example 'na tagged -d 3 feature idea', desc: 'Show all actions tagged either @feature or @idea, recurse 3 levels'

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.default_value 1
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.action do |global_options, options, args|
      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end

      tags = []
      args.each do |arg|
        # TODO: <> comparisons do nothing right now
        m = arg.match(/^(?<req>\+)?(?<tag>[^ =<>]+)(?:(?<op>[=<>]+)(?<val>\S+))?$/)
        tags.push({
                    tag: m['tag'],
                    comp: m['op'],
                    value: m['val'],
                    required: !m['req'].nil?
                  })
      end

      actions = NA.parse_actions(depth: depth,
                                 extension: global_options[:ext],
                                 na_tag: global_options[:na_tag],
                                 tag: tags)
      NA.output_actions(actions, depth, global_options[:ext])
    end
  end


  desc 'Open a todo file in the default editor'
  long_desc 'Let the system choose the defualt, (e.g. TaskPaper), or specify a command line utility (e.g. vim).
             If more than one todo file is found, a menu is displayed.'
  command %i[edit] do |c|
    c.example 'na edit', desc: 'Open the main todo file in the default editor'
    c.example 'na edit -d 3 -a vim', desc: 'Display a menu of all todo files three levels deep from the
               current directory, open selection in vim.'

    c.desc 'Recurse to depth'
    c.arg_name 'DEPTH'
    c.default_value 1
    c.flag %i[d depth], type: :integer, must_match: /^\d+$/

    c.desc 'Specify an editor CLI'
    c.arg_name 'EDITOR'
    c.flag %i[e editor]

    c.desc 'Specify a Mac app'
    c.arg_name 'EDITOR'
    c.flag %i[a app]

    c.action do |global_options, options, args|
      depth = if global_options[:recurse] && options[:depth].nil? && global_options[:depth] == 1
                3
              else
                options[:depth].nil? ? global_options[:depth].to_i : options[:depth].to_i
              end
      files = NA.find_files(depth: depth, extension: global_options[:ext])
      file = if files.count > 1
               NA.select_file(files)
             else
               files[0]
             end

      if options[:editor]
        system %(#{options[:editor]} "#{file}")
      else
        NA.edit_file(file: file, app: options[:app])
      end
    end
  end

  pre do |global,command,options,args|
    # Pre logic here
    # Return true to proceed; false to abort and not call the
    # chosen command
    # Use skips_pre before a command to skip this block
    # on that command only
    true
  end

  post do |global,command,options,args|
    # Post logic here
    # Use skips_post before a command to skip this
    # block on that command only
  end

  on_error do |exception|
    case exception
    when GLI::UnknownCommand
      cmd = ['add']
      if ARGV.count.positive?
        cmd.concat(ARGV.unshift($first_arg))
      end

      exit run(cmd)
    when SystemExit
      false
    else
      true
    end
  end
end

@command = ARGV[0]
$first_arg = ARGV[1]

exit App.run(ARGV)
